"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[1263],{1991:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"engine-configuration/data-sources/http","title":"HTTP RESTful API","description":"Learn how to configure HTTP RESTful APIs as data sources in the `hugr` GraphQL engine to enable integration with external services.","source":"@site/docs/4-engine-configuration/1-data-sources/4-http.md","sourceDirName":"4-engine-configuration/1-data-sources","slug":"/engine-configuration/data-sources/http","permalink":"/docs/engine-configuration/data-sources/http","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/4-engine-configuration/1-data-sources/4-http.md","tags":[],"version":"current","lastUpdatedBy":"vgsml","lastUpdatedAt":1749654481000,"sidebarPosition":5,"frontMatter":{"label":"HTTP RESTful API","sidebar_position":5,"keywords":["HTTP","REST","API","Data Source","GraphQL"],"description":"Learn how to configure HTTP RESTful APIs as data sources in the `hugr` GraphQL engine to enable integration with external services."},"sidebar":"docsSidebar","previous":{"title":"MySQL","permalink":"/docs/engine-configuration/data-sources/mysql"},"next":{"title":"Extensions & Cross-Source Subqueries","permalink":"/docs/engine-configuration/data-sources/extension"}}');var i=t(4848),r=t(8453);const d={label:"HTTP RESTful API",sidebar_position:5,keywords:["HTTP","REST","API","Data Source","GraphQL"],description:"Learn how to configure HTTP RESTful APIs as data sources in the `hugr` GraphQL engine to enable integration with external services."},c="HTTP RESTful API",a={},o=[{value:"Set up HTTP RESTful API Data Source",id:"set-up-http-restful-api-data-source",level:2},{value:"Perform HTTP Requests",id:"perform-http-requests",level:2},{value:"Path and Parameters",id:"path-and-parameters",level:2},{value:"Security Settings",id:"security-settings",level:2},{value:"OAuth2 Customization",id:"oauth2-customization",level:2},{value:"Self-Describing APIs",id:"self-describing-apis",level:2},{value:"Format",id:"format",level:3},{value:"Schema Generation",id:"schema-generation",level:3},{value:"Add Function Views",id:"add-function-views",level:2},{value:"Extend Data Objects with Function Calls",id:"extend-data-objects-with-function-calls",level:2},{value:"Examples",id:"examples",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"http-restful-api",children:"HTTP RESTful API"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," GraphQL engine supports HTTP RESTful APIs as data sources, allowing you to integrate external services into your GraphQL schema. This is particularly useful for fetching data from third-party APIs or microservices."]}),"\n",(0,i.jsx)(n.h2,{id:"set-up-http-restful-api-data-source",children:"Set up HTTP RESTful API Data Source"}),"\n",(0,i.jsxs)(n.p,{children:["To configure an HTTP RESTful API as a data source in the ",(0,i.jsx)(n.code,{children:"hugr"})," engine, create a data source record in the ",(0,i.jsx)(n.code,{children:"data_sources"})," table using the GraphQL API. The ",(0,i.jsx)(n.code,{children:"path"})," should contain the base URL of the API. You can also specify additional parameters to configure security, provide an OpenAPI specification, and set other options."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"mutation addHttpDataSource($data: data_sources_mut_input_data! = {}) {\n  core {\n    insert_data_sources(data: $data) {\n      name\n      description\n      as_module\n      disabled\n      path\n      prefix\n      read_only\n      self_defined\n      type\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "name": "http_api",\n    "type": "http",\n    "path": "https://api.example.com",\n    "prefix": "api",\n    "description": "My HTTP RESTful API data source",\n    "read_only": false,\n    "self_defined": false,\n    "as_module": true,\n    "disabled": false\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"perform-http-requests",children:"Perform HTTP Requests"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," engine supports the ",(0,i.jsx)(n.code,{children:"http"})," data source type for HTTP REST APIs. Internally, HTTP data sources use the DuckDB backend to fetch data via the special SQL function ",(0,i.jsx)(n.code,{children:"http_data_source_request_scalar"}),". This function allows you to make HTTP requests and retrieve data in a structured format for use in your GraphQL queries. To add HTTP RESTful APIs to the unified GraphQL schema, define ",(0,i.jsx)(n.code,{children:"hugr"})," functions as ",(0,i.jsx)(n.code,{children:"http_data_source_request_scalar"})," calls."]}),"\n",(0,i.jsxs)(n.p,{children:["This function is also accessible through the ",(0,i.jsx)(n.code,{children:"hugr"})," GraphQL API, allowing you to query external REST APIs directly in your GraphQL queries:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'query getCurrentWeather{\n  function{\n    core{\n      http_data_source_request_scalar(\n        source: "owm"\n        path: "/data/2.5/weather"\n        method: "GET"\n        headers: {},\n        parameters: {\n          lat: 35.6895\n          lon: 139.6917\n        },\n        body: {},\n        jq: ""\n      )\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To add API calls as functions to the GraphQL schema, define catalogs for the data source with the function definitions, or add an OpenAPI specification and mark the data source as ",(0,i.jsx)(n.code,{children:"self_defined"}),". The ",(0,i.jsx)(n.code,{children:"hugr"})," engine will automatically generate the GraphQL schema based on the OpenAPI specification or the function definitions in the catalogs."]}),"\n",(0,i.jsx)(n.h2,{id:"path-and-parameters",children:"Path and Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"path"})," should contain the base URL of the API. You can also specify additional parameters such as headers, query parameters, and request body. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine uses these parameters to make HTTP requests to the API. The path should look like ",(0,i.jsx)(n.code,{children:"https://api.example.com/v1/resource?params=param_value"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The URL without parameters is used as the base URL for API calls, while parameters are provided separately. Below is a full list of parameters that can be used to configure the HTTP data source:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-security"})}),(0,i.jsx)(n.td,{children:"JSON"}),(0,i.jsx)(n.td,{children:"The string encoded JSON object that defines security settings for the data source. See the full list of object fields below."}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'{"schema_name": "owm", "type": "http", "scheme": "basic", "username": "user", "password": "pass"}'})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-spec-uri"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsx)(n.td,{children:"The URL to the OpenAPI specification for the API. This is used to generate the GraphQL schema for the API."}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"https://api.example.com/openapi.json"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-spec-path"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsx)(n.td,{children:"The path to the OpenAPI specification file. This can be a local file."}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"/workspace/owm/spec.yaml"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"security-settings",children:"Security Settings"}),"\n",(0,i.jsxs)(n.p,{children:["Security settings configure authentication and authorization for the HTTP data source. The ",(0,i.jsx)(n.code,{children:"x-hugr-security"})," parameter should contain a JSON object with the following fields:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Field"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"schema_name"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsx)(n.td,{children:"The name of the security schema in the OpenAPI specification"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"type"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The type of the security scheme, e.g., ",(0,i.jsx)(n.code,{children:"http"}),", ",(0,i.jsx)(n.code,{children:"oauth2"}),", ",(0,i.jsx)(n.code,{children:"apiKey"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"scheme"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The scheme name, used when the type field is ",(0,i.jsx)(n.code,{children:"http"}),". Should be ",(0,i.jsx)(n.code,{children:"basic"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"name"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The name of the security scheme, used when the type field is ",(0,i.jsx)(n.code,{children:"apiKey"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"in"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The location of the API key, ",(0,i.jsx)(n.code,{children:"header"})," or ",(0,i.jsx)(n.code,{children:"query"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"api_key"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The API key value, used when the type field is ",(0,i.jsx)(n.code,{children:"apiKey"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"username"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The username for basic authentication, used when the type is ",(0,i.jsx)(n.code,{children:"http"})," or ",(0,i.jsx)(n.code,{children:"oauth2"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"password"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The password for basic authentication, used when the type is ",(0,i.jsx)(n.code,{children:"http"})," or ",(0,i.jsx)(n.code,{children:"oauth2"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"client_id"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The client ID for OAuth2 authentication, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"client_secret"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The client secret for OAuth2 authentication, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"flow_name"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The name of the OAuth2 flow, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"}),". The flow will search in the ",(0,i.jsx)(n.code,{children:"flows"})," field or in the OpenAPI specification security schema (defined by ",(0,i.jsx)(n.code,{children:"name"})," =",(0,i.jsx)(n.code,{children:"schema_name"})," and ",(0,i.jsx)(n.code,{children:"type"})," = ",(0,i.jsx)(n.code,{children:"oauth2"}),")."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"flows"})}),(0,i.jsx)(n.td,{children:"Object"}),(0,i.jsxs)(n.td,{children:["The OAuth2 flows object, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"}),". This should be an OpenAPI3 OAuthFlows object. If the OpenAPI specification is provided, the flows from the OpenAPI specification from the selected security schema name will be used."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"timeout"})}),(0,i.jsx)(n.td,{children:"Duration"}),(0,i.jsx)(n.td,{children:"The timeout for HTTP requests, used to limit the time spent on each request. Default is 30 seconds."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," engine supports the following flow types for the ",(0,i.jsx)(n.code,{children:"oauth2"})," security scheme:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"clientCredentials"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"password"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"oauth2-customization",children:"OAuth2 Customization"}),"\n",(0,i.jsxs)(n.p,{children:["Many HTTP APIs use token authentication that is not fully compatible with the OAuth2 specification. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine supports customization of the token and refresh token requests."]}),"\n",(0,i.jsxs)(n.p,{children:["You can customize the ",(0,i.jsx)(n.code,{children:"oauth2"})," flow as shown in the following example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'openapi: 3.1.0\ninfo:\n  title: Test Server\n  version: 1.0.0\nservers:\n  - url: http://localhost:8080\n    description: Local server\ncomponents:\n  securitySchemes:\n    oauth2_custom:\n      type: oauth2\n      description: Custom OAuth 2.0 flow\n      flows:\n        password:\n          tokenUrl: /custom_login\n          x-hugr-token-transform:\n            method: POST\n            request_body: "{login: $username, password: $password}"\n            response_body: "{access_token: .accessToken, refresh_token: .refreshToken, token_type: \\"bearer\\", expires_in: 3600}"\n          refreshUrl: /custom_refresh\n          x-hugr-refresh-transform:\n            method: POST\n            request_body: "{refreshToken: .refresh_token}"\n            response_body: "{access_token: .accessToken, refresh_token: .refreshToken, token_type: \\"bearer\\", expires_in: 3600}"\n          scopes:\n            read: Read access\n            write: Write access\n    oauth2:\n      type: oauth2\n      description: OAuth 2.0\n      flows:\n        password:\n          tokenUrl: /token_with_refresh\n          scopes:\n            read: Read access\n            write: Write access\n        clientCredentials:\n          tokenUrl: /token_with_refresh\n          scopes:\n            read: Read access\n            write: Write access\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To customize the OAuth2 flow, you can use the ",(0,i.jsx)(n.code,{children:"x-hugr-token-transform"})," and ",(0,i.jsx)(n.code,{children:"x-hugr-refresh-transform"})," fields to define request and response body jq transformations. These transformations allow you to adapt the request and response formats to match the requirements of the API you are integrating with. In these jq transformations, you can also use the following variables from the security settings:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$username"})," - the username from the security settings"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$type"})," - the type of the security scheme, e.g. ",(0,i.jsx)(n.code,{children:"http"}),", ",(0,i.jsx)(n.code,{children:"oauth2"}),", ",(0,i.jsx)(n.code,{children:"apiKey"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$schema_name"})," - the name of the security schema in the OpenAPI specification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$flow"})," - the name of the OAuth2 flow, used to select the flow from the ",(0,i.jsx)(n.code,{children:"flows"})," field or from the OpenAPI specification security schema"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$scheme"})," - the scheme name, used when the type field is ",(0,i.jsx)(n.code,{children:"http"}),". Should be ",(0,i.jsx)(n.code,{children:"basic"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$api_key_name"})," - the name of the API key, used when the type field is ",(0,i.jsx)(n.code,{children:"apiKey"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$api_key_in"})," - the location of the API key, ",(0,i.jsx)(n.code,{children:"header"})," or ",(0,i.jsx)(n.code,{children:"query"}),", used when the type field is ",(0,i.jsx)(n.code,{children:"apiKey"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$api_key"})," - the API key value, used when the type field is ",(0,i.jsx)(n.code,{children:"apiKey"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$username"})," - the username for basic authentication, used when the type is ",(0,i.jsx)(n.code,{children:"http"})," or ",(0,i.jsx)(n.code,{children:"oauth2"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$password"})," - the password for basic authentication, used when the type is ",(0,i.jsx)(n.code,{children:"http"})," or ",(0,i.jsx)(n.code,{children:"oauth2"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$client_id"})," - the client ID for OAuth2 authentication, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$client_secret"})," - the client secret for OAuth2 authentication, used when the type is ",(0,i.jsx)(n.code,{children:"oauth2"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The original request or response body is used as jq input, and the output is used as the new request or response body. This allows you to transform the request and response bodies to match the requirements of the API you are integrating with."}),"\n",(0,i.jsx)(n.h2,{id:"self-describing-apis",children:"Self-Describing APIs"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," engine supports self-describing APIs, allowing you to define the API schema using an OpenAPI specification. Use the ",(0,i.jsx)(n.code,{children:"x-hugr-spec-uri"})," or ",(0,i.jsx)(n.code,{children:"x-hugr-spec-path"})," parameters to specify the OpenAPI specification for the API. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine will use this specification to generate the GraphQL schema for the API."]}),"\n",(0,i.jsx)(n.h3,{id:"format",children:"Format"}),"\n",(0,i.jsxs)(n.p,{children:["The OpenAPI specification can be provided in either JSON or YAML format. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine will automatically detect the format based on the file extension or the content type of the response."]}),"\n",(0,i.jsx)(n.h3,{id:"schema-generation",children:"Schema Generation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," engine will generate the GraphQL schema based on the OpenAPI specification. For each endpoint and method, a ",(0,i.jsx)(n.code,{children:"hugr"})," function will be generated, which can be used to query the API. In addition to functions, the required GraphQL types will be generated based on the OpenAPI specification."]}),"\n",(0,i.jsxs)(n.p,{children:["The GraphQL specification has strict requirements for schema definition names. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine automatically converts OpenAPI specification names to valid GraphQL names by removing special characters (such as spaces, dashes, and other non-alphanumeric or non-English characters). Invalid characters are replaced with ",(0,i.jsx)(n.code,{children:"X"}),". Nested OpenAPI schema objects include the parent name as a prefix, ensuring unique names in the GraphQL schema. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine generates the GraphQL schema, including types and fields, based on the OpenAPI specification."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hugr"})," engine also allows you to specify your own field name and type transformations. For this purpose, special OpenAPI extension fields can be used:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Field"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-name"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsx)(n.td,{children:"The name of the field in the GraphQL schema. This can be used to override the default name generated from the OpenAPI specification."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-type"})}),(0,i.jsx)(n.td,{children:"Object"}),(0,i.jsx)(n.td,{children:"The type of the field in the GraphQL schema. This can be used to override the default type generated from the OpenAPI specification."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-type.transform"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The transformation name to apply to the field values. Currently implemented: ",(0,i.jsx)(n.code,{children:"FromUnixTime"}),", ",(0,i.jsx)(n.code,{children:"StringAsGeoJson"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-type.geometry_info"})}),(0,i.jsx)(n.td,{children:"Object"}),(0,i.jsx)(n.td,{children:"The geometry information for the field in the GraphQL schema. This can be used to override the default geometry information."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-type.geometry_info.geometry_type"})}),(0,i.jsx)(n.td,{children:"String"}),(0,i.jsxs)(n.td,{children:["The type of the geometry, e.g. ",(0,i.jsx)(n.code,{children:"Point"}),", ",(0,i.jsx)(n.code,{children:"LineString"}),", ",(0,i.jsx)(n.code,{children:"Polygon"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"x-hugr-field-type.geometry_info.srid"})}),(0,i.jsx)(n.td,{children:"Integer"}),(0,i.jsxs)(n.td,{children:["The SRID of the geometry, e.g. ",(0,i.jsx)(n.code,{children:"4326"})," for WGS 84."]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Example of the OpenAPI specification with the ",(0,i.jsx)(n.code,{children:"x-hugr-field-name"})," and ",(0,i.jsx)(n.code,{children:"x-hugr-field-type"})," fields:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'openapi: 3.1.0\ninfo:\n  title: OpenWeatherMap\n  version: 0.0.1\nservers:\n  - url: https://api.openweathermap.org\n    description: OpenWeatherMap\ncomponents:\n  securitySchemes:\n    owm:\n      type: apiKey\n      description: API key authentication\n      in: query\n      name: appid\n  schemas:\n    current_weather:\n      type: object\n        dt:\n          type: integer\n          x-hugr-type:\n            type: Timestamp\n            transform: "FromUnixTime"\n        rain:\n          $ref: "#/components/schemas/perc_info"\n        snow:\n          $ref: "#/components/schemas/perc_info"\n        sys:\n          type: object\n          x-hugr-name: "common"\n          properties:\n            sunrise:\n              type: integer\n              x-hugr-type:\n                type: Timestamp\n                transform: "FromUnixTime"\n            sunset:\n              type: integer\n              x-hugr-type:\n                type: Timestamp\n                transform: "FromUnixTime"\n    perc_info:\n      type: object\n      properties:\n        1h:\n          type: number\n          x-hugr-name: current\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the ",(0,i.jsx)(n.code,{children:"dt"})," field is converted to the ",(0,i.jsx)(n.code,{children:"Timestamp"})," type using the ",(0,i.jsx)(n.code,{children:"FromUnixTime"})," transformation. The ",(0,i.jsx)(n.code,{children:"sys"})," object is renamed to ",(0,i.jsx)(n.code,{children:"common"}),". The ",(0,i.jsx)(n.code,{children:"sys.sunrise"})," and ",(0,i.jsx)(n.code,{children:"sys.sunset"})," fields are also converted to the ",(0,i.jsx)(n.code,{children:"Timestamp"})," type using the ",(0,i.jsx)(n.code,{children:"FromUnixTime"})," transformation. The ",(0,i.jsx)(n.code,{children:"1h"})," field in the ",(0,i.jsx)(n.code,{children:"perc_info"})," object is renamed to ",(0,i.jsx)(n.code,{children:"current"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"add-function-views",children:"Add Function Views"}),"\n",(0,i.jsxs)(n.p,{children:["The GraphQL schema generated by ",(0,i.jsx)(n.code,{children:"hugr"})," includes types and functions based on the OpenAPI specification. However, you can also define your own functions to extend the schema with additional functionality or to create custom parameterized views of external data. Technically, the ",(0,i.jsx)(n.code,{children:"http"})," data source is a memory DuckDB data source, so you can define functions in the same way as for the DuckDB data source. The ",(0,i.jsx)(n.code,{children:"hugr"})," engine will automatically generate the GraphQL schema based on the defined functions."]}),"\n",(0,i.jsx)(n.p,{children:"You can add additional catalog sources that contain view definitions, as shown in the example below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'type devices_view @view(name: "devices_view",\n        sql: """\n            SELECT data.*\n            FROM (\n                (SELECT UNNEST(json_transform(http_data_source_request_scalar(\n                    \'[$catalog]\', \'/devices\', \'POST\', \'{}\'::JSON, \'{}\'::JSON, \'{}\'::JSON, \n                    \'.items[] | {id: .id, name: .name, number: .number, address: .address, is_managed: .isManaged, coordinates: .coordinates}\'\n                )::JSON, \'[{"address": "VARCHAR", "coordinates": "VARCHAR", "id":"VARCHAR", "is_managed": "BOOLEAN", "name": "VARCHAR", "number": "VARCHAR"}]\')) AS data) \n            )\n        """\n    ) \n    @module(name: "iot") {\n    id: String\n    name: String\n    number: String\n    address: String\n    is_managed: Boolean\n    geom: Geometry @field_source(field: "coordinates") @geometry_info(srid: 4326, type: POINT) @sql(exp: "ST_GeomFromGeoJSON(geom)")\n    telemetry: devices_telemetry_view @join(references_name: "devices_telemetry_view", source_fields: ["id"], references_fields: ["id"])\n}\n\ntype devices_telemetry_view @view(name: "devices_telemetry_view" \n    sql: """\n        WITH devices AS (\n            SELECT LIST(data.id) AS ids\n            FROM (SELECT UNNEST(json_transform(http_data_source_request_scalar(\'[$catalog]\', \'/devices\', \'POST\', \'{}\'::JSON, \'{}\'::JSON, \'{}\'::JSON, \'. | .items[] | {id: .id, is_managed: .isManaged}\')::JSON, \'[{"id":"VARCHAR", "is_managed": "BOOLEAN"}]\')) AS data) \n            WHERE data.is_managed\n        ), telemetry_response AS (\n            SELECT http_data_source_request_scalar(\'[$catalog]\', \'/devices/telemetry\', \'POST\', \'{}\'::JSON, \'{}\'::JSON, {deviceIds: devices.ids}::JSON, \n                \'.devicesTelemetry[] | {id: .id, dateTimeEvent: .dateTimeEvent, stateTypeId: .stateTypeId, controlTypeId: .controlTypeId, errors: .errors}\')::JSON AS response\n            FROM devices\n        )\n        SELECT data.*\n        FROM (\n            SELECT UNNEST(json_transform(telemetry_response.response, \n                \'[{"id": "VARCHAR", "dateTimeEvent": "VARCHAR", "stateTypeId": "INTEGER", "controlTypeId": "INTEGER", "errors": "JSON"}]\'\n            )) AS data\n            FROM telemetry_response \n        )\n    """\n) @module(name: "iot") {\n    id: String\n    eventTime: Timestamp @sql(exp: "try_cast(dateTimeEvent AS TIMESTAMP)")\n    stateTypeId: Int @field_references(field: "id", references_name: "status_types_view", query: "state", references_query: "devices_telemetry")\n    controlTypeId: Int @field_references(field: "id", references_name: "control_types_view", query: "control", references_query: "devices_telemetry")\n    errors: JSON\n}\n\n\ntype status_types_view @view(name: "status_types_view",\n        sql: """\n            FROM (VALUES\n                (1,\'Managed\'),\n                (2,\'Monitoring\'),\n                (3,\'No connection\'),\n                (4,\'Error\'),\n                (5,\'Unmonitored\'),\n            ) as data(id,name)\n        """\n    )\n    @module(name: "iot") {\n    id: Int! @pk\n    name: String\n}\n\ntype control_types_view @view(name: "control_types_view",\n        sql: """\n            FROM (VALUES\n                (1, \'unknown\'),\n                (2, \'manual control\'),\n                (3, \'automatic control\'),\n                (4, \'remote control\'),\n                (5, \'local control\')\n            ) as data(id,name)\n        """\n    ) \n    @module(name: "iot") {\n    id: Int @pk\n    name: String\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This example defines two views: ",(0,i.jsx)(n.code,{children:"devices_view"})," and ",(0,i.jsx)(n.code,{children:"devices_telemetry_view"}),". The ",(0,i.jsx)(n.code,{children:"devices_view"})," fetches data from the ",(0,i.jsx)(n.code,{children:"/devices"})," endpoint and transforms it into a structured format. The ",(0,i.jsx)(n.code,{children:"devices_telemetry_view"})," fetches telemetry data for the devices and joins it with the ",(0,i.jsx)(n.code,{children:"devices_view"})," based on the device ID.",(0,i.jsx)(n.br,{}),"\n","After defining these views, you can use them in your GraphQL queries to fetch, aggregate, or join data with other data objects."]}),"\n",(0,i.jsx)(n.h2,{id:"extend-data-objects-with-function-calls",children:"Extend Data Objects with Function Calls"}),"\n",(0,i.jsx)(n.p,{children:"Once the data source is configured and the functions are defined, you can use them in your GraphQL queries to fetch data from the external API. You can also extend data objects from other data sources with function call fields, allowing you to perform calls with table values as parameters, as shown in the example below."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"{\n  dicts{\n    common{\n      dictionary_types{\n        id\n        name\n        test_get{\n          name\n          value\n        }  \n      }\n      dictionary_types_aggregation{\n        test_get{\n          name{\n            count\n          }\n          value{\n            sum\n          }\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:["You can find examples of using HTTP RESTful APIs as data sources in the ",(0,i.jsx)(n.code,{children:"hugr"})," examples repository. Notable examples include:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/examples/rest-owm",children:"OpenWeatherMap Example"})," \u2013 demonstrates how to use the OpenWeatherMap API to fetch current weather data, using API key authentication."]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);