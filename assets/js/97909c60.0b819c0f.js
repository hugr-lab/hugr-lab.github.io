"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[5562],{7450:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"examples/h3-spatial","title":"H3 Spatial Example","description":"Learn how to create geoembeddings using H3 hexagons with Hugr.","source":"@site/docs/9-examples/6-h3-spatial.md","sourceDirName":"9-examples","slug":"/examples/h3-spatial","permalink":"/docs/examples/h3-spatial","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/9-examples/6-h3-spatial.md","tags":[],"version":"current","lastUpdatedBy":"vgsml","lastUpdatedAt":1756711789000,"sidebarPosition":6,"frontMatter":{"title":"H3 Spatial Example","sidebar_position":6,"description":"Learn how to create geoembeddings using H3 hexagons with Hugr."},"sidebar":"docsSidebar","previous":{"title":"DuckDB: Spatial - OpenStreetMap Example","permalink":"/docs/examples/duckdb-spatial"},"next":{"title":"SQL Server: Adventure Works","permalink":"/docs/examples/mssql"}}');var s=a(4848),i=a(8453);const o={title:"H3 Spatial Example",sidebar_position:6,description:"Learn how to create geoembeddings using H3 hexagons with Hugr."},d=void 0,l={},r=[{value:"Data source",id:"data-source",level:2},{value:"Create a OSM data source",id:"create-a-osm-data-source",level:3},{value:"Create a Population data source",id:"create-a-population-data-source",level:3},{value:"Join OSM and Population data",id:"join-osm-and-population-data",level:2},{value:"Split population data into H3 hexagons distributed by sum of residential building areas",id:"split-population-data-into-h3-hexagons-distributed-by-sum-of-residential-building-areas",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Hugr can help you to create geoembeddings from your data based on the H3 DSG. H3 is a geospatial indexing system that allows you to represent geographic locations as hexagonal grids. This can be useful for various applications, such as spatial analysis, mapping, and data visualization."}),"\n",(0,s.jsxs)(n.p,{children:["Hugr provides a special type of data query called ",(0,s.jsx)(n.code,{children:"h3"})," that allows you to aggregate you data into h3 hexagons. The ",(0,s.jsx)(n.code,{children:"h3"})," query can be used to create geoembeddings from your data by aggregating it into H3 hexagons based on the spatial fields in your data tables and views."]}),"\n",(0,s.jsx)(n.h2,{id:"data-source",children:"Data source"}),"\n",(0,s.jsxs)(n.p,{children:["We will use the OpenStreetMap (OSM) data for Baden-W\xfcrttemberg, Germany, and Population data from the ",(0,s.jsx)(n.a,{href:"https://www.zensus2022.de/static/Zensus_Veroeffentlichung/Regionaltabelle_Bevoelkerung.xlsx",children:"German Federal Statistical Office (Destatis)"})," as our data sources."]}),"\n",(0,s.jsx)(n.h3,{id:"create-a-osm-data-source",children:"Create a OSM data source"}),"\n",(0,s.jsxs)(n.p,{children:["To create a data source for the OSM data you can use the existing ",(0,s.jsx)(n.a,{href:"https://github.com/hugr-lab/osm_dbt",children:"OSM dbt project"})," as a starting point or following by the ",(0,s.jsx)(n.a,{href:"/docs/examples/duckdb-spatial",children:"Example"})," to create a DuckDB database with the OSM data."]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, we should extend the OSM data source to add calculated field for the county code (osm tag ",(0,s.jsx)(n.code,{children:"de:amtlicher_gemeindeschluesselz"}),") in osm_administrative_boundaries table. This will allow us to join the OSM data with the population data later."]}),"\n",(0,s.jsxs)(n.p,{children:["We will add additional catalog file ",(0,s.jsx)(n.code,{children:"osm_extension.graphql"})," to the OSM data source with the following content:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"extend type osm_administrative_boundaries {\n  de_code: String @sql(\n    exp: \"(tags->>'de:amtlicher_gemeindeschluessel')\"\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And now we can add this file as a catalog source for the OSM BW:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'mutation addOsmExtend{\n  core{\n    insert_catalog_sources(data:{\n      name: "osm_extend_de_code"\n      description: "Add de code to the osm admin boundaries"\n      type: "uriFile"\n      path: "~/workspace/examples/h3/osm_extend.graphql"\n    }){\n      name\n      path\n      type\n    }\n    insert_catalogs(data:{\n      data_source_name: "osm.bw"\n      catalog_name: "osm_extend_de_code"\n    }) {\n      success\n      affected_rows\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Than you can reload the OSM BW data source to apply the changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'mutation reloadOsmDataSource {\n  function{\n    reload_data_source(\n      name: "osm.bw"\n    ) {\n      success\n      message\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"create-a-population-data-source",children:"Create a Population data source"}),"\n",(0,s.jsxs)(n.p,{children:["To create a data source for the population data, we will use the ",(0,s.jsx)(n.a,{href:"https://www.zensus2022.de/static/Zensus_Veroeffentlichung/Regionaltabelle_Bevoelkerung.xlsx",children:"Destatis Zensus 2022"})," Excel file. We can convert this file to a DuckDB table using the ",(0,s.jsx)(n.code,{children:"hugr"})," engine."]}),"\n",(0,s.jsx)(n.p,{children:"To do this follow the steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Download the Excel file and place it in your workspace, e.g. ",(0,s.jsx)(n.code,{children:"~/workspace/examples/h3/population.xlsx"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Save the worksheet ",(0,s.jsx)(n.code,{children:"Regionaltabelle_Bevoelkerung"})," as a csv file, e.g. ",(0,s.jsx)(n.code,{children:"examples/h3/population.csv"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"To create a duckdb file with the population data, you can run following bash script:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\nduckdb examples/h3/zensus.duckdb -c \"CREATE TABLE population AS SELECT * FROM read_csv_auto('examples/h3/population.csv');\"\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Now we can create a DuckDB data source for the population data:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'mutation addZensusDataSource {\n  core {\n    insert_data_sources(data: {\n      name: "zensus",\n      type: "duckdb",\n      prefix: "zensus",\n      description: "Zensus 2022 population data",\n      path: "/workspace/examples/h3/zensus.duckdb"\n      as_module: true,\n      read_only: true,\n      self_defined: true,\n    }) {\n      success\n      affected_rows\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Load the data source:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'mutation loadZensusDataSource {\n  core {\n    load_data_source(name: "zensus") {\n      success\n      message\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"join-osm-and-population-data",children:"Join OSM and Population data"}),"\n",(0,s.jsxs)(n.p,{children:["Now you are able to join the OSM data with the population data using the ",(0,s.jsx)(n.code,{children:"de_code"})," field we added to the OSM data source. You can use the following query to get the population data for each OSM administrative boundary:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query debw{\n  osm{\n    bw{\n      osm_administrative_boundaries(filter: {admin_level: {eq: 6}}){\n        osm_id\n        name\n        de_code\n        _join(fields:["de_code"]){\n          zensus_population(fields: ["db_RS"]){\n            db_RS\n            Name\n            EWZ\n          }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This query will return the OSM administrative boundaries for admin level 7 (Landkreis) for Baden-W\xfcrttemberg with the population data from the Zensus 2022. The ",(0,s.jsx)(n.code,{children:"de_code"})," field is used to join the OSM data with the population data."]}),"\n",(0,s.jsx)(n.h2,{id:"split-population-data-into-h3-hexagons-distributed-by-sum-of-residential-building-areas",children:"Split population data into H3 hexagons distributed by sum of residential building areas"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query deOSMByH3 {\n  h3(resolution: 6) @stats{\n    cell\n    resolution\n    data{\n      lk: osm_bw_osm_administrative_boundaries_aggregation(\n        field: "geom"\n        filter:{admin_level: {eq:6}},\n        divide_values:false\n        inner: true\n      ){\n        pop: _join(fields: ["de_code"]) {\n          zensus_population(fields: ["db_RS"]){\n            EWZ{\n              sum\n            }\n          }\n        }\n      }\n      houses: osm_bw_osm_buildings_aggregation(\n        field: "geom"\n        filter: {building_class: {eq:"residential"}}\n      ){\n        _rows_count\n        area_sqm{\n          sum\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This query will return the H3 hexagons in Baden-W\xfcrttemberg with the population data from the Zensus 2022 and the residential building areas from the OSM data. The ",(0,s.jsx)(n.code,{children:"h3"})," query is used to aggregate the OSM data into H3 hexagons based on the spatial fields in the OSM data tables."]}),"\n",(0,s.jsx)(n.p,{children:"Let's extend the query to calculate the population density in each H3 hexagon:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query deOSMByH3 {\n  h3(resolution: 6) @stats{\n    cell\n    resolution\n    data{\n      lk: osm_bw_osm_administrative_boundaries_aggregation(\n        field: "geom"\n        filter:{admin_level: {eq:6}},\n        divide_values:false\n        inner: true\n      ){\n        pop: _join(fields: ["de_code"]) {\n          zensus_population(fields: ["db_RS"]){\n            EWZ{\n              sum\n            }\n          }\n        }\n      }\n      houses: osm_bw_osm_buildings_aggregation(\n        field: "geom"\n        filter: {building_class: {eq:"residential"}}\n      ){\n        _rows_count\n        area_sqm{\n          sum\n        }\n      }\n    }\n    pop: distribution_by(\n      numerator: "data.lk.pop.zensus_population.EWZ.sum"\n      denominator: "data.houses.area_sqm.sum"\n    ){\n      value\n      ratio\n      numerator\n      denominator\n      denominator_total\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This query will return the H3 hexagons in Baden-W\xfcrttemberg with the population density calculated as the ratio of the population to the residential building area. The ",(0,s.jsx)(n.code,{children:"distribution_by"})," field is used to calculate the population density in each H3 hexagon by the following formula:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"value = numerator * denominator / sum(denominator)"})}),"\n",(0,s.jsxs)(n.p,{children:["Where ",(0,s.jsx)(n.code,{children:"numerator"})," is the population data and ",(0,s.jsx)(n.code,{children:"denominator"})," is the residential building area in each H3 hexagon. For the population data aggregation we have used the ",(0,s.jsx)(n.code,{children:"inner: true"}),", that means that the sum of denominator will be calculated only for the H3 hexagons that have population data."]}),"\n",(0,s.jsxs)(n.p,{children:["As well you can calculate the population density by buckets, to do this you can use the ",(0,s.jsx)(n.code,{children:"distribution_by_bucket"})," field:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query deOSMByH3 {\n  h3(resolution: 6) @stats{\n    cell\n    resolution\n    data{\n      lk: osm_bw_osm_administrative_boundaries_aggregation(\n        field: "geom"\n        filter:{admin_level: {eq:6}},\n        divide_values:false\n        inner: true\n      ){\n        pop: _join(fields: ["de_code"]) {\n          zensus_population(fields: ["db_RS"]){\n            EWZ{\n              sum\n            }\n          }\n        }\n      }\n      houses_bucket: osm_bw_osm_buildings_bucket_aggregation(\n        field: "geom"\n        filter: {building_class: {eq:"residential"}}\n      ){\n        key{\n          building_type\n        }\n        aggregations{\n          _rows_count\n          area_sqm{\n            sum\n          }\n        }\n      }\n    }\n    pop_by_bucket: distribution_by_bucket(\n      numerator: "data.lk.pop.zensus_population.EWZ.sum"\n      denominator_key: "data.houses_bucket.key"\n      denominator: "data.houses_bucket.aggregations.area_sqm.sum"\n    ){\n      denominator_key\n      value\n      ratio\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This query will return the H3 hexagons in Baden-W\xfcrttemberg with the population density calculated by buckets based on the residential building area. The ",(0,s.jsx)(n.code,{children:"distribution_by_bucket"})," field is used to calculate the population density in each H3 hexagon by the same formula, but denominator points to the bucket aggregation of the residential building area. The ",(0,s.jsx)(n.code,{children:"denominator_key"})," is used to select key field in the base aggregation."]}),"\n",(0,s.jsx)(n.p,{children:"As well numerator can point to the bucket aggregation, so you can calculate the distribution by bucket for the numerator as well."}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we have shown how to use the ",(0,s.jsx)(n.code,{children:"hugr"})," engine to create geoembeddings from your data based on the H3 DSG. We have used the OSM data for Baden-W\xfcrttemberg and the population data from the Zensus 2022 to create H3 hexagons with population density calculated by residential building areas. The ",(0,s.jsx)(n.code,{children:"h3"})," query allows you to aggregate your data into H3 hexagons based on the spatial fields in your data tables and views, making it easy to create geoembeddings for various applications."]}),"\n",(0,s.jsxs)(n.p,{children:["You can apply this approach to any spatial data you have, as long as you can define the spatial fields in your data tables and views. The ",(0,s.jsx)(n.code,{children:"hugr"})," engine provides a powerful way to work with spatial data and create geoembeddings that can be used for various applications, such as spatial analysis, mapping, data visualization and ",(0,s.jsx)(n.strong,{children:"Machine Learning"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>d});var t=a(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);