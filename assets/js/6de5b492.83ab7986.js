"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[3648],{838:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"engine-configuration/extension","title":"Extensions & Cross-Source Subqueries","description":"Comprehensive guide to using extensions for cross-source data integration in Hugr","source":"@site/docs/4-engine-configuration/4-extension.md","sourceDirName":"4-engine-configuration","slug":"/engine-configuration/extension","permalink":"/docs/engine-configuration/extension","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/4-engine-configuration/4-extension.md","tags":[],"version":"current","lastUpdatedBy":"Claude","lastUpdatedAt":1762713621000,"sidebarPosition":5,"frontMatter":{"title":"Extensions & Cross-Source Subqueries","sidebar_position":5,"description":"Comprehensive guide to using extensions for cross-source data integration in Hugr","keywords":["extensions","cross-source","joins","function calls","dependencies","data integration"]},"sidebar":"docsSidebar","previous":{"title":"Module Organization","permalink":"/docs/engine-configuration/schema-definition/modules"},"next":{"title":"Access Control","permalink":"/docs/engine-configuration/access-control"}}');var r=s(4848),t=s(8453);const o={title:"Extensions & Cross-Source Subqueries",sidebar_position:5,description:"Comprehensive guide to using extensions for cross-source data integration in Hugr",keywords:["extensions","cross-source","joins","function calls","dependencies","data integration"]},a="Extensions & Cross-Source Subqueries",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Extension Data Source",id:"extension-data-source",level:3},{value:"Type Prefixes",id:"type-prefixes",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Setting Up an Extension",id:"setting-up-an-extension",level:2},{value:"1. Create Extension Data Source",id:"1-create-extension-data-source",level:3},{value:"2. Create Extension Schema",id:"2-create-extension-schema",level:3},{value:"3. Load the Extension",id:"3-load-the-extension",level:3},{value:"Extending Types with Cross-Source Joins",id:"extending-types-with-cross-source-joins",level:2},{value:"Basic Cross-Source Join",id:"basic-cross-source-join",level:3},{value:"Multiple Cross-Source Joins",id:"multiple-cross-source-joins",level:3},{value:"Extending Types with Cross-Source Function Calls",id:"extending-types-with-cross-source-function-calls",level:2},{value:"Basic Function Call",id:"basic-function-call",level:3},{value:"Table Function Call with Join",id:"table-function-call-with-join",level:3},{value:"Creating Custom Views Across Data Sources",id:"creating-custom-views-across-data-sources",level:2},{value:"Cross-Source SQL View",id:"cross-source-sql-view",level:3},{value:"Parameterized Cross-Source View",id:"parameterized-cross-source-view",level:3},{value:"Advanced DuckDB Features in Views",id:"advanced-duckdb-features-in-views",level:3},{value:"Using DuckDB Analytical Functions",id:"using-duckdb-analytical-functions",level:4},{value:"Using http_data_source_request_scalar() for HTTP Data Sources",id:"using-http_data_source_request_scalar-for-http-data-sources",level:4},{value:"Complex Analytical Queries",id:"complex-analytical-queries",level:4},{value:"Adding Documentation to Schema Types and Fields",id:"adding-documentation-to-schema-types-and-fields",level:2},{value:"Documenting Existing Types",id:"documenting-existing-types",level:3},{value:"Documenting Modules",id:"documenting-modules",level:3},{value:"Complete Documentation Example",id:"complete-documentation-example",level:3},{value:"Using Dynamic Joins (_join) for Cross-Source Queries",id:"using-dynamic-joins-_join-for-cross-source-queries",level:2},{value:"Cross-Source Dynamic Join",id:"cross-source-dynamic-join",level:3},{value:"Using inner Argument",id:"using-inner-argument",level:3},{value:"Multiple Source Aggregation",id:"multiple-source-aggregation",level:3},{value:"Cross-Source Aggregation Types",id:"cross-source-aggregation-types",level:3},{value:"Using Spatial Queries (_spatial) Across Sources",id:"using-spatial-queries-_spatial-across-sources",level:2},{value:"Cross-Source Spatial Join",id:"cross-source-spatial-join",level:3},{value:"Spatial Join with Filter and Inner",id:"spatial-join-with-filter-and-inner",level:3},{value:"Complete Extension Example",id:"complete-extension-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Declare Dependencies",id:"1-always-declare-dependencies",level:3},{value:"2. Use Descriptive Prefixes",id:"2-use-descriptive-prefixes",level:3},{value:"3. Document Your Extensions",id:"3-document-your-extensions",level:3},{value:"4. Filter Cross-Source Joins",id:"4-filter-cross-source-joins",level:3},{value:"5. Use inner for Required Relationships",id:"5-use-inner-for-required-relationships",level:3},{value:"6. Optimize SQL Views",id:"6-optimize-sql-views",level:3},{value:"7. Test Extensions Incrementally",id:"7-test-extensions-incrementally",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Pattern 1: Data Enrichment",id:"pattern-1-data-enrichment",level:3},{value:"Pattern 2: Unified Reporting",id:"pattern-2-unified-reporting",level:3},{value:"Pattern 3: Federated Aggregation",id:"pattern-3-federated-aggregation",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Error: &quot;Dependency not loaded&quot;",id:"error-dependency-not-loaded",level:3},{value:"Error: &quot;Type not found&quot;",id:"error-type-not-found",level:3},{value:"Error: &quot;Circular dependency detected&quot;",id:"error-circular-dependency-detected",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"See Also",id:"see-also",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"extensions--cross-source-subqueries",children:"Extensions & Cross-Source Subqueries"})}),"\n",(0,r.jsx)(n.p,{children:"Extensions are a powerful feature in Hugr that enable you to extend existing data objects with cross-source subquery and function call fields. They allow seamless integration of data from multiple sources, creating a unified GraphQL API that spans different databases and systems."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Extensions enable powerful cross-data-source capabilities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-source joins"}),": Add join fields that reference tables from other data sources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-source function calls"}),": Call functions from different data sources as fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom SQL views"}),": Create views combining data from multiple sources using DuckDB SQL"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema documentation"}),": Add or update descriptions for existing types and fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type prefixes"}),": Reference types from different sources using their prefixes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency tracking"}),": Define dependencies between extensions and data sources"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"extension-data-source",children:"Extension Data Source"}),"\n",(0,r.jsx)(n.p,{children:"An extension is a special type of data source that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doesn't require a connection string (path is empty)"}),"\n",(0,r.jsx)(n.li,{children:"Depends on one or more other data sources"}),"\n",(0,r.jsx)(n.li,{children:"Extends existing types from those sources"}),"\n",(0,r.jsx)(n.li,{children:"Can define custom SQL views across sources"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"type-prefixes",children:"Type Prefixes"}),"\n",(0,r.jsxs)(n.p,{children:["When working with multiple data sources, each data source can have a ",(0,r.jsx)(n.strong,{children:"prefix"})," defined in the ",(0,r.jsx)(n.code,{children:"data_sources"})," table (in the ",(0,r.jsx)(n.code,{children:"core"})," module). This prefix is used to namespace types and avoid naming conflicts."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'Data source "postgres_main"'})," with prefix ",(0,r.jsx)(n.code,{children:'"pg"'})," \u2192 types like ",(0,r.jsx)(n.code,{children:"pg_users"}),", ",(0,r.jsx)(n.code,{children:"pg_orders"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'Data source "mysql_analytics"'})," with prefix ",(0,r.jsx)(n.code,{children:'"mysql"'})," \u2192 types like ",(0,r.jsx)(n.code,{children:"mysql_sessions"}),", ",(0,r.jsx)(n.code,{children:"mysql_events"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The prefix is set in the data source configuration and prepended to all table/view names from that source."}),"\n",(0,r.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,r.jsxs)(n.p,{children:["Extensions must declare their dependencies on other data sources using the ",(0,r.jsx)(n.code,{children:"@dependency"})," directive. This ensures proper loading order and prevents referencing unavailable types."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important"}),": The ",(0,r.jsx)(n.code,{children:"@dependency"})," directive requires the ",(0,r.jsx)(n.strong,{children:"data source name"})," from the ",(0,r.jsx)(n.code,{children:"data_sources"})," table (the ",(0,r.jsx)(n.code,{children:"name"})," field), not the module name."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend type pg_users @dependency(name: "postgres_db") @dependency(name: "analytics") {\n  # Depends on both "postgres_db" (for pg_users) and "analytics" (for referenced types)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"You must declare dependencies for ALL data sources involved"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The data source containing the type you're extending (e.g., ",(0,r.jsx)(n.code,{children:"postgres_db"})," for ",(0,r.jsx)(n.code,{children:"pg_users"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["All data sources containing types you reference (e.g., ",(0,r.jsx)(n.code,{children:"analytics"})," for ",(0,r.jsx)(n.code,{children:"mysql_user_sessions"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": If extending ",(0,r.jsx)(n.code,{children:"pg_users"})," from data source ",(0,r.jsx)(n.code,{children:"postgres_db"})," with data from ",(0,r.jsx)(n.code,{children:"analytics"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend type pg_users\n  @dependency(name: "postgres_db")  # Source of the extended type\n  @dependency(name: "analytics")    # Source of referenced types\n{\n  sessions: [mysql_user_sessions] @join(...)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"setting-up-an-extension",children:"Setting Up an Extension"}),"\n",(0,r.jsx)(n.h3,{id:"1-create-extension-data-source",children:"1. Create Extension Data Source"}),"\n",(0,r.jsx)(n.p,{children:"Add an extension data source record through the GraphQL API:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  core {\n    insert_data_sources(data: {\n      name: "ext_cross_source"\n      type: "extension"\n      path: ""\n      prefix: ""\n      description: "Cross-source data integration extension"\n      read_only: false\n      self_defined: false\n      as_module: false\n      disabled: false\n      catalogs: [\n        {\n          name: "ext_cross_source"\n          description: "Extension schema catalog"\n          type: "uri"\n          path: "/workspace/schemes/ext_cross_source"\n        }\n      ]\n    }) {\n      name\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'type: "extension"'})," - marks this as an extension data source"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'path: ""'})," - no connection string needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'prefix: ""'})," - optional prefix for view types defined in extension"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"catalogs"})," - defines where the extension schema files are located"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-create-extension-schema",children:"2. Create Extension Schema"}),"\n",(0,r.jsxs)(n.p,{children:["Create a GraphQL schema file in the catalog path (e.g., ",(0,r.jsx)(n.code,{children:"/workspace/schemes/ext_cross_source/schema.graphql"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Extend existing types with cross-source fields\nextend type pg_customers @dependency(name: "analytics") {\n  # Add fields here\n}\n\n# Define custom views\ntype custom_view @view(...) {\n  # View fields\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-load-the-extension",children:"3. Load the Extension"}),"\n",(0,r.jsx)(n.p,{children:"After creating the schema, load the extension through the Hugr admin UI or API. The extension will validate dependencies and extend the GraphQL schema."}),"\n",(0,r.jsx)(n.h2,{id:"extending-types-with-cross-source-joins",children:"Extending Types with Cross-Source Joins"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"@join"})," directive to add fields that reference data from other sources."]}),"\n",(0,r.jsx)(n.h3,{id:"basic-cross-source-join",children:"Basic Cross-Source Join"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Extend PostgreSQL users table with data from MySQL analytics\nextend type pg_users\n  @dependency(name: "postgres_db")  # Data source containing pg_users\n  @dependency(name: "analytics")    # Data source containing mysql_user_sessions\n{\n  # Add sessions from MySQL analytics database\n  sessions: [mysql_user_sessions]\n    @join(\n      references_name: "mysql_user_sessions"\n      source_fields: ["email"]\n      references_fields: ["user_email"]\n    )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pg_users"})," - type from PostgreSQL (prefix ",(0,r.jsx)(n.code,{children:"pg"}),", data source ",(0,r.jsx)(n.code,{children:"postgres_db"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mysql_user_sessions"})," - type from MySQL (prefix ",(0,r.jsx)(n.code,{children:"mysql"}),", data source ",(0,r.jsx)(n.code,{children:"analytics"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'@dependency(name: "postgres_db")'})," - declares dependency on source of extended type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'@dependency(name: "analytics")'})," - declares dependency on source of referenced types"]}),"\n",(0,r.jsxs)(n.li,{children:["Join condition: ",(0,r.jsx)(n.code,{children:"pg_users.email = mysql_user_sessions.user_email"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"query {\n  postgres_db {\n    pg_users {\n      id\n      email\n      name\n      # Sessions from MySQL\n      sessions {\n        session_id\n        start_time\n        duration\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multiple-cross-source-joins",children:"Multiple Cross-Source Joins"}),"\n",(0,r.jsx)(n.p,{children:"Extend a type with fields from multiple sources:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend type pg_orders\n  @dependency(name: "postgres_db")  # Data source containing pg_orders\n  @dependency(name: "warehouse")    # Data source containing duckdb_inventory\n  @dependency(name: "crm")          # Data source containing crm_customer_interactions\n{\n  # Inventory data from DuckDB warehouse\n  inventory_items: [duckdb_inventory]\n    @join(\n      references_name: "duckdb_inventory"\n      source_fields: ["product_id"]\n      references_fields: ["product_id"]\n    )\n\n  # Customer relationship data from CRM system\n  crm_interactions: [crm_customer_interactions]\n    @join(\n      references_name: "crm_customer_interactions"\n      source_fields: ["customer_id"]\n      references_fields: ["customer_id"]\n    )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"query {\n  postgres_db {\n    pg_orders(limit: 10) {\n      id\n      customer_id\n      product_id\n      # From DuckDB warehouse\n      inventory_items {\n        warehouse_location\n        stock_quantity\n      }\n      # From CRM system\n      crm_interactions {\n        interaction_type\n        interaction_date\n        notes\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"extending-types-with-cross-source-function-calls",children:"Extending Types with Cross-Source Function Calls"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"@function_call"})," directive to add fields that call functions from other data sources. When calling functions from different modules, you must specify the ",(0,r.jsx)(n.code,{children:"module"})," parameter."]}),"\n",(0,r.jsx)(n.h3,{id:"basic-function-call",children:"Basic Function Call"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Extend orders with shipping cost calculation from external API\nextend type pg_orders\n  @dependency(name: "postgres_db")  # Data source containing pg_orders\n  @dependency(name: "shipping_api") # Data source containing calculate_shipping function\n{\n  # Calculate shipping cost using function from HTTP data source\n  shipping_cost: Float\n    @function_call(\n      references_name: "calculate_shipping"\n      module: "shipping_api"\n      args: {\n        weight: "total_weight"\n        destination: "shipping_address"\n      }\n    )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'module: "shipping_api"'})," - specifies which data source module contains the function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'references_name: "calculate_shipping"'})," - function name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"args"})," - maps order fields to function parameters"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"query {\n  postgres_db {\n    pg_orders {\n      id\n      total_weight\n      shipping_address\n      # Calculated by external function\n      shipping_cost\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"table-function-call-with-join",children:"Table Function Call with Join"}),"\n",(0,r.jsx)(n.p,{children:"For functions that return arrays of data that need to be joined:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend type pg_products\n  @dependency(name: "postgres_db")          # Data source containing pg_products\n  @dependency(name: "recommendation_engine") # Data source containing the function\n{\n  # Get recommendations from ML service\n  related_products: [recommendation_result]\n    @table_function_call_join(\n      references_name: "get_product_recommendations"\n      module: "recommendation_engine"\n      args: {\n        product_id: "id"\n        category: "category_name"\n      }\n      source_fields: ["id"]\n      references_fields: ["source_product_id"]\n    )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Function returns array of recommendations"}),"\n",(0,r.jsxs)(n.li,{children:["Results are joined: ",(0,r.jsx)(n.code,{children:"pg_products.id = recommendation_result.source_product_id"})]}),"\n",(0,r.jsxs)(n.li,{children:["Function is called with ",(0,r.jsx)(n.code,{children:"product_id"})," and ",(0,r.jsx)(n.code,{children:"category"})," parameters"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"query {\n  postgres_db {\n    pg_products(limit: 5) {\n      id\n      name\n      category_name\n      # Recommendations from ML engine\n      related_products {\n        recommended_product_id\n        similarity_score\n        reason\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"creating-custom-views-across-data-sources",children:"Creating Custom Views Across Data Sources"}),"\n",(0,r.jsx)(n.p,{children:"Extensions can define SQL views that combine data from multiple sources using the full power of DuckDB SQL. Dependencies must be declared for all data sources used in the view."}),"\n",(0,r.jsx)(n.h3,{id:"cross-source-sql-view",children:"Cross-Source SQL View"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# View combining PostgreSQL orders with MySQL customer data\ntype order_customer_summary\n  @view(\n    name: "order_customer_summary"\n    sql: """\n      SELECT\n        o.id as order_id,\n        o.total,\n        o.order_date,\n        c.customer_id,\n        c.name as customer_name,\n        c.lifetime_value\n      FROM postgres_db.public.orders o\n      INNER JOIN analytics.customers c ON o.customer_id = c.customer_id\n      WHERE o.status = \'completed\'\n    """\n  )\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n{\n  order_id: Int!\n  total: Float!\n  order_date: Timestamp!\n  customer_id: Int!\n  customer_name: String!\n  lifetime_value: Float\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"SQL uses DuckDB's unified query context"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Full table names"}),": ",(0,r.jsx)(n.code,{children:"data_source_name.schema.table_name"})," format","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"postgres_db.public.orders"})," - orders table from postgres_db data source, public schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"analytics.customers"})," - customers table from analytics data source (default schema)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Can join tables from different sources using full names"}),"\n",(0,r.jsx)(n.li,{children:"Dependencies declared for both data sources"}),"\n",(0,r.jsx)(n.li,{children:"Schema name can be omitted if using the default schema"}),"\n",(0,r.jsx)(n.li,{children:"View appears as a queryable type in the schema"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  order_customer_summary(\n    filter: { lifetime_value: { gte: 10000 } }\n    order_by: [{ field: "total", direction: DESC }]\n  ) {\n    order_id\n    total\n    customer_name\n    lifetime_value\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"parameterized-cross-source-view",children:"Parameterized Cross-Source View"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type regional_sales_summary\n  @view(\n    name: "regional_sales_summary"\n    sql: """\n      SELECT\n        r.region_id,\n        r.region_name,\n        COUNT(DISTINCT o.id) as order_count,\n        SUM(o.total) as total_sales,\n        AVG(o.total) as avg_order_value\n      FROM postgres_db.public.regions r\n      LEFT JOIN postgres_db.public.orders o ON o.region_id = r.region_id\n      WHERE r.country = [$country]\n        AND o.order_date >= [$start_date]\n        AND o.order_date <= [$end_date]\n      GROUP BY r.region_id, r.region_name\n    """\n  )\n  @dependency(name: "postgres_db")\n  @args(name: "sales_filters")\n{\n  region_id: Int!\n  region_name: String!\n  order_count: Int!\n  total_sales: Float!\n  avg_order_value: Float!\n}\n\ninput sales_filters {\n  country: String!\n  start_date: Date!\n  end_date: Date!\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  regional_sales_summary(\n    args: {\n      country: "USA"\n      start_date: "2024-01-01"\n      end_date: "2024-12-31"\n    }\n  ) {\n    region_name\n    order_count\n    total_sales\n    avg_order_value\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-duckdb-features-in-views",children:"Advanced DuckDB Features in Views"}),"\n",(0,r.jsx)(n.p,{children:"Extensions can leverage the full power of DuckDB's analytical functions and features in SQL views."}),"\n",(0,r.jsx)(n.h4,{id:"using-duckdb-analytical-functions",children:"Using DuckDB Analytical Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type product_sales_analysis\n  @view(\n    name: "product_sales_analysis"\n    sql: """\n      SELECT\n        p.product_id,\n        p.name,\n        SUM(s.quantity) as total_quantity,\n        SUM(s.revenue) as total_revenue,\n        AVG(s.revenue) as avg_revenue,\n        -- Window functions\n        ROW_NUMBER() OVER (PARTITION BY p.category ORDER BY SUM(s.revenue) DESC) as rank_in_category,\n        -- Percentile functions\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY s.revenue) as median_revenue,\n        -- String aggregation\n        STRING_AGG(DISTINCT s.customer_id::VARCHAR, \', \') as customer_ids\n      FROM postgres_db.public.products p\n      LEFT JOIN analytics.sales s ON p.product_id = s.product_id\n      GROUP BY p.product_id, p.name, p.category\n    """\n  )\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n{\n  product_id: Int!\n  name: String!\n  total_quantity: Int!\n  total_revenue: Float!\n  avg_revenue: Float!\n  rank_in_category: Int!\n  median_revenue: Float\n  customer_ids: String\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"using-http_data_source_request_scalar-for-http-data-sources",children:"Using http_data_source_request_scalar() for HTTP Data Sources"}),"\n",(0,r.jsxs)(n.p,{children:["For HTTP data sources, use Hugr's ",(0,r.jsx)(n.code,{children:"http_data_source_request_scalar()"})," function to make API calls within DuckDB views:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"type weather_enriched_locations\n  @view(\n    name: \"weather_enriched_locations\"\n    sql: \"\"\"\n      SELECT\n        l.location_id,\n        l.city,\n        l.latitude,\n        l.longitude,\n        -- Call HTTP API using http_data_source_request_scalar\n        (\n          http_data_source_request_scalar(\n            'weather_api',              -- Data source name\n            '/weather/current',         -- API endpoint path\n            'GET',                      -- HTTP method\n            '{}'::JSON,                 -- Request body (empty for GET)\n            json_object(                -- Query parameters\n              'lat', l.latitude,\n              'lon', l.longitude\n            ),\n            '{}'::JSON,                 -- Headers\n            ''                          -- Additional options\n          )::JSON\n        )->>'temperature' as current_temp,\n        (\n          http_data_source_request_scalar(\n            'weather_api',\n            '/weather/current',\n            'GET',\n            '{}'::JSON,\n            json_object('lat', l.latitude, 'lon', l.longitude),\n            '{}'::JSON,\n            ''\n          )::JSON\n        )->>'humidity' as current_humidity\n      FROM postgres_db.public.locations l\n    \"\"\"\n  )\n  @dependency(name: \"postgres_db\")\n  @dependency(name: \"weather_api\")\n{\n  location_id: Int!\n  city: String!\n  latitude: Float!\n  longitude: Float!\n  current_temp: String\n  current_humidity: String\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Function signature"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"http_data_source_request_scalar(\n  data_source_name VARCHAR,  -- Name from data_sources table\n  path VARCHAR,              -- API endpoint path\n  method VARCHAR,            -- HTTP method (GET, POST, etc.)\n  body JSON,                 -- Request body\n  params JSON,               -- Query parameters\n  headers JSON,              -- HTTP headers\n  options VARCHAR            -- Additional options\n) RETURNS VARCHAR\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"http_data_source_request_scalar()"})," - makes HTTP requests to configured data sources"]}),"\n",(0,r.jsx)(n.li,{children:"Returns response as VARCHAR, cast to JSON for parsing"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"->"})," and ",(0,r.jsx)(n.code,{children:"->>"})," operators to extract JSON fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"json_object()"})," constructs query parameters from table columns"]}),"\n",(0,r.jsx)(n.li,{children:"Useful for enriching database data with external API data"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"complex-analytical-queries",children:"Complex Analytical Queries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type customer_cohort_analysis\n  @view(\n    name: "customer_cohort_analysis"\n    sql: """\n      WITH first_purchase AS (\n        SELECT\n          customer_id,\n          MIN(order_date) as cohort_date,\n          DATE_TRUNC(\'month\', MIN(order_date)) as cohort_month\n        FROM postgres_db.public.orders\n        GROUP BY customer_id\n      ),\n      customer_orders AS (\n        SELECT\n          o.customer_id,\n          o.order_date,\n          o.total,\n          fp.cohort_month,\n          DATEDIFF(\'month\', fp.cohort_date, o.order_date) as months_since_first\n        FROM postgres_db.public.orders o\n        INNER JOIN first_purchase fp ON o.customer_id = fp.customer_id\n      )\n      SELECT\n        cohort_month,\n        months_since_first,\n        COUNT(DISTINCT customer_id) as active_customers,\n        SUM(total) as total_revenue,\n        AVG(total) as avg_order_value,\n        -- Retention calculation\n        COUNT(DISTINCT customer_id) * 100.0 /\n          FIRST_VALUE(COUNT(DISTINCT customer_id)) OVER (\n            PARTITION BY cohort_month\n            ORDER BY months_since_first\n          ) as retention_rate\n      FROM customer_orders\n      GROUP BY cohort_month, months_since_first\n      ORDER BY cohort_month, months_since_first\n    """\n  )\n  @dependency(name: "postgres_db")\n{\n  cohort_month: Date!\n  months_since_first: Int!\n  active_customers: Int!\n  total_revenue: Float!\n  avg_order_value: Float!\n  retention_rate: Float!\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Available DuckDB features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Window functions (ROW_NUMBER, RANK, LAG, LEAD, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"CTEs (Common Table Expressions)"}),"\n",(0,r.jsx)(n.li,{children:"Aggregation functions (percentiles, statistical functions)"}),"\n",(0,r.jsx)(n.li,{children:"Date/time functions (DATE_TRUNC, DATEDIFF, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"String functions (STRING_AGG, CONCAT, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Array and JSON functions"}),"\n",(0,r.jsx)(n.li,{children:"Geospatial functions (when spatial extension is enabled)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"adding-documentation-to-schema-types-and-fields",children:"Adding Documentation to Schema Types and Fields"}),"\n",(0,r.jsx)(n.p,{children:"Extensions allow you to add or modify descriptions (documentation) for existing types and fields from other data sources."}),"\n",(0,r.jsx)(n.h3,{id:"documenting-existing-types",children:"Documenting Existing Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Add documentation to existing PostgreSQL tables\n"Customer accounts in the system"\nextend type pg_customers @dependency(name: "postgres_db") {\n  "Unique customer identifier"\n  id: Int!\n\n  "Customer email address for notifications"\n  email: String!\n\n  "Current account status (active, suspended, closed)"\n  status: String!\n\n  "Customer lifetime value in USD"\n  lifetime_value: Float\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"documenting-modules",children:"Documenting Modules"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Add description to a module\'s query type\n"Analytics queries provide access to business intelligence and reporting data from the MySQL analytics database.\nIncludes customer behavior analysis, sales metrics, and user engagement statistics."\nextend type _module_analytics_query @dependency(name: "analytics") {\n  _stub: String\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Module query types follow pattern: ",(0,r.jsx)(n.code,{children:"_module_<module_name>_query"})]}),"\n",(0,r.jsx)(n.li,{children:"Descriptions appear in GraphQL schema documentation"}),"\n",(0,r.jsx)(n.li,{children:"Helps developers understand what data and operations are available"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"complete-documentation-example",children:"Complete Documentation Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Document medical data module\n"Synthetic medical records database generated using Synthea.\nContains realistic patient health records, encounters, medications, and clinical observations\nfor the California region. Used for testing and development of healthcare applications."\nextend type _module_medical_data_query @dependency(name: "medical_data") {\n  _stub: String\n}\n\n"Patient demographic and identity information"\nextend type medical_patients @dependency(name: "medical_data") {\n  "Unique patient identifier (UUID format)"\n  id: String!\n\n  "Patient\'s date of birth"\n  birthdate: Date!\n\n  "Patient\'s current city of residence"\n  city: String\n\n  "Geographic coordinates of patient\'s address"\n  geom: Geometry @geometry_info(type: POINT, srid: 4326)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"using-dynamic-joins-_join-for-cross-source-queries",children:"Using Dynamic Joins (_join) for Cross-Source Queries"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"_join"})," field is available on all data objects and provides a powerful way to perform ad-hoc joins across data sources at query time, without pre-defining relationships in the schema."]}),"\n",(0,r.jsx)(n.h3,{id:"cross-source-dynamic-join",children:"Cross-Source Dynamic Join"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_customers {\n      id\n      email\n      # Join with analytics data from MySQL at query time\n      _join(fields: ["email"]) {\n        mysql_user_behavior(fields: ["user_email"]) {\n          page_views\n          session_count\n          last_visit\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Dynamic join: ",(0,r.jsx)(n.code,{children:"pg_customers.email = mysql_user_behavior.user_email"})]}),"\n",(0,r.jsx)(n.li,{children:"No pre-defined relationship needed in schema"}),"\n",(0,r.jsx)(n.li,{children:"Join happens at query time across different databases"}),"\n",(0,r.jsx)(n.li,{children:"Hugr uses DuckDB to execute the cross-source join"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"using-inner-argument",children:"Using inner Argument"}),"\n",(0,r.jsx)(n.p,{children:"Control join type to filter parent records:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_products {\n      id\n      name\n      # Only products that have warehouse inventory\n      _join(fields: ["sku"]) {\n        duckdb_warehouse_inventory(\n          fields: ["product_sku"]\n          inner: true  # INNER JOIN - excludes products without inventory\n        ) {\n          warehouse_location\n          quantity\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"inner: true"})," - only returns products that exist in warehouse inventory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"inner: false"})," (default) - returns all products, even without inventory (LEFT JOIN)"]}),"\n",(0,r.jsx)(n.li,{children:"Useful for filtering data based on existence in related sources"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"multiple-source-aggregation",children:"Multiple Source Aggregation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_customers(limit: 100) {\n      id\n      name\n      # Aggregate orders from PostgreSQL\n      _join(fields: ["id"]) {\n        pg_orders_aggregation(fields: ["customer_id"]) {\n          _rows_count\n          total { sum avg }\n        }\n      }\n      # Aggregate sessions from MySQL\n      _join(fields: ["email"]) {\n        mysql_sessions_aggregation(fields: ["user_email"]) {\n          _rows_count\n          duration { sum avg }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": Get customer statistics from multiple sources in a single query."]}),"\n",(0,r.jsx)(n.h3,{id:"cross-source-aggregation-types",children:"Cross-Source Aggregation Types"}),"\n",(0,r.jsx)(n.p,{children:"When using extensions with cross-source joins, it's important to understand how GraphQL types behave:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Input Types"})," (",(0,r.jsx)(n.code,{children:"_filter"})," argument):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Do NOT change"})," - remain specific to each data source"]}),"\n",(0,r.jsx)(n.li,{children:"Use the original filter types for each source"}),"\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:"pg_orders"})," uses ",(0,r.jsx)(n.code,{children:"pg_orders_filter"}),", ",(0,r.jsx)(n.code,{children:"mysql_sessions"})," uses ",(0,r.jsx)(n.code,{children:"mysql_sessions_filter"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Aggregation Types"})," (",(0,r.jsx)(n.code,{children:"_aggregation"})," and bucket aggregations):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"DO change"})," - become cross-source aware"]}),"\n",(0,r.jsx)(n.li,{children:"Can aggregate over fields from joined sources"}),"\n",(0,r.jsx)(n.li,{children:"Enable grouping and aggregation across multiple data sources"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example - Aggregating with Joined Data"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_customers_bucket_aggregation {\n      key {\n        country\n        # Can group by joined data from analytics source\n        _join(fields: ["email"]) {\n          mysql_user_behavior(fields: ["user_email"]) {\n            user_segment  # Field from analytics source\n          }\n        }\n      }\n      aggregations {\n        _rows_count\n        # Can aggregate original fields\n        lifetime_value { sum avg }\n        # Can aggregate joined data\n        _join(fields: ["id"]) {\n          pg_orders_aggregation(fields: ["customer_id"]) {\n            total { sum avg }\n          }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"This enables"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Group customers by country AND user segment from analytics"}),"\n",(0,r.jsx)(n.li,{children:"Aggregate both customer lifetime value AND order totals"}),"\n",(0,r.jsx)(n.li,{children:"Create cross-source analytical queries"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter vs Aggregation behavior"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_customers(\n      # \u274c Filter remains source-specific\n      filter: { country: { eq: "USA" } }  # Only pg_customers fields\n    ) {\n      id\n      # \u2705 Aggregations can include joined sources\n      _join(fields: ["id"]) {\n        pg_orders_aggregation(fields: ["customer_id"]) {\n          _rows_count\n          total { sum }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"using-spatial-queries-_spatial-across-sources",children:"Using Spatial Queries (_spatial) Across Sources"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"_spatial"})," field enables geographic queries across different data sources."]}),"\n",(0,r.jsx)(n.h3,{id:"cross-source-spatial-join",children:"Cross-Source Spatial Join"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_stores {\n      id\n      name\n      location\n      # Find customers from MySQL within 5km\n      _spatial(field: "location", type: DWITHIN, buffer: 5000) {\n        mysql_customers(field: "address_location") {\n          customer_id\n          name\n          distance\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spatial relationship: customers within 5km of store"}),"\n",(0,r.jsx)(n.li,{children:"Works across different databases (PostgreSQL and MySQL)"}),"\n",(0,r.jsx)(n.li,{children:"DuckDB's spatial extension handles the geographic calculation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"spatial-join-with-filter-and-inner",children:"Spatial Join with Filter and Inner"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  duckdb_delivery_zones {\n    zone_id\n    zone_name\n    boundary\n    # Only zones with active orders from PostgreSQL\n    _spatial(field: "boundary", type: CONTAINS) {\n      pg_orders(\n        field: "delivery_location"\n        filter: { status: { in: ["pending", "processing"] } }\n        inner: true  # Only zones containing active orders\n      ) {\n        order_id\n        status\n        delivery_location\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spatial containment check: orders within zone boundaries"}),"\n",(0,r.jsx)(n.li,{children:"Filter applied: only active orders"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"inner: true"})," - excludes zones without matching orders"]}),"\n",(0,r.jsx)(n.li,{children:"Combines spatial and attribute filters for precise results"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"complete-extension-example",children:"Complete Extension Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example showing multiple cross-source integration techniques:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Extension Schema"})," (",(0,r.jsx)(n.code,{children:"/workspace/schemes/ext_cross_source/schema.graphql"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Extend PostgreSQL customers with cross-source data\nextend type pg_customers\n  @dependency(name: "postgres_db")   # Source of pg_customers\n  @dependency(name: "analytics")     # Source of mysql_user_behavior\n  @dependency(name: "warehouse")     # Source of warehouse data\n  @dependency(name: "shipping_api")  # Source of shipping functions\n{\n  # Join: MySQL analytics data\n  behavior_metrics: [mysql_user_behavior]\n    @join(\n      references_name: "mysql_user_behavior"\n      source_fields: ["email"]\n      references_fields: ["user_email"]\n    )\n\n  # Function call: Calculate shipping eligibility\n  shipping_eligible: Boolean\n    @function_call(\n      references_name: "check_shipping_eligibility"\n      module: "shipping_api"\n      args: {\n        customer_id: "id"\n        country: "country"\n      }\n    )\n}\n\n# Extend PostgreSQL orders\nextend type pg_orders\n  @dependency(name: "postgres_db")  # Source of pg_orders\n  @dependency(name: "warehouse")    # Source of duckdb_inventory\n{\n  # Join: Warehouse inventory\n  warehouse_status: [duckdb_inventory]\n    @join(\n      references_name: "duckdb_inventory"\n      source_fields: ["product_id"]\n      references_fields: ["product_id"]\n    )\n}\n\n# Cross-source view\ntype customer_order_analytics\n  @view(\n    name: "customer_order_analytics"\n    sql: """\n      SELECT\n        c.id as customer_id,\n        c.name as customer_name,\n        c.email,\n        COUNT(o.id) as total_orders,\n        SUM(o.total) as total_spent,\n        AVG(b.session_count) as avg_sessions\n      FROM postgres_db.public.customers c\n      LEFT JOIN postgres_db.public.orders o ON c.id = o.customer_id\n      LEFT JOIN analytics.user_behavior b ON c.email = b.user_email\n      GROUP BY c.id, c.name, c.email\n    """\n  )\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n{\n  customer_id: Int!\n  customer_name: String!\n  email: String!\n  total_orders: Int!\n  total_spent: Float!\n  avg_sessions: Float\n}\n\n# Add documentation\n"Customer analytics combining order history and behavioral data"\nextend type _module_analytics_query @dependency(name: "analytics") {\n  _stub: String\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query CustomerAnalytics {\n  # Query the cross-source view\n  customer_order_analytics(\n    filter: { total_orders: { gte: 5 } }\n    order_by: [{ field: "total_spent", direction: DESC }]\n    limit: 10\n  ) {\n    customer_name\n    email\n    total_orders\n    total_spent\n    avg_sessions\n  }\n\n  # Query extended types\n  postgres_db {\n    pg_customers(limit: 5) {\n      id\n      name\n      email\n\n      # Cross-source join field\n      behavior_metrics {\n        page_views\n        session_count\n      }\n\n      # Cross-source function call\n      shipping_eligible\n\n      # Dynamic join with analytics\n      _join(fields: ["id"]) {\n        mysql_loyalty_points(fields: ["customer_id"]) {\n          points_balance\n          tier_level\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-always-declare-dependencies",children:"1. Always Declare Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Good - All dependencies declared\nextend type pg_users\n  @dependency(name: "postgres_db")  # Source of pg_users\n  @dependency(name: "analytics")    # Source of mysql_sessions\n{\n  sessions: [mysql_sessions] @join(...)\n}\n\n# Bad - Missing dependencies\nextend type pg_users {\n  sessions: [mysql_sessions] @join(...)  # Will fail!\n}\n\n# Bad - Missing source dependency\nextend type pg_users @dependency(name: "analytics") {\n  sessions: [mysql_sessions] @join(...)  # Missing postgres_db dependency!\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),": Hugr uses dependencies to:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validate type references"}),"\n",(0,r.jsx)(n.li,{children:"Determine loading order"}),"\n",(0,r.jsx)(n.li,{children:"Track data source relationships"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-use-descriptive-prefixes",children:"2. Use Descriptive Prefixes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "postgres_main",\n  "prefix": "pg",  // Clear and concise\n  "as_module": true\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Makes type origins clear in queries"}),"\n",(0,r.jsx)(n.li,{children:"Prevents naming conflicts"}),"\n",(0,r.jsx)(n.li,{children:"Improves schema readability"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-document-your-extensions",children:"3. Document Your Extensions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'"Enhanced customer data with analytics and CRM integration"\nextend type pg_customers\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n{\n  "Customer engagement score from analytics engine"\n  engagement_score: Float @function_call(...)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Helps developers understand extended fields"}),"\n",(0,r.jsx)(n.li,{children:"Appears in GraphQL schema introspection"}),"\n",(0,r.jsx)(n.li,{children:"Makes API self-documenting"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-filter-cross-source-joins",children:"4. Filter Cross-Source Joins"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  pg_customers {\n    id\n    _join(fields: ["email"]) {\n      mysql_sessions(\n        fields: ["user_email"]\n        filter: { session_date: { gte: "2024-01-01" } }  # Filter to reduce data\n      ) {\n        id\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduces data transfer between sources"}),"\n",(0,r.jsx)(n.li,{children:"Improves query performance"}),"\n",(0,r.jsx)(n.li,{children:"Limits memory usage"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-use-inner-for-required-relationships",children:"5. Use inner for Required Relationships"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  pg_orders {\n    id\n    _join(fields: ["customer_id"]) {\n      pg_customers(\n        fields: ["id"]\n        inner: true  # Only orders with valid customers\n      ) {\n        name\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Filters out orphaned records"}),"\n",(0,r.jsx)(n.li,{children:"Ensures data integrity in results"}),"\n",(0,r.jsx)(n.li,{children:"Makes query intent clear"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"6-optimize-sql-views",children:"6. Optimize SQL Views"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type optimized_summary\n  @view(\n    sql: """\n      SELECT\n        -- Only select needed columns\n        o.id, o.total, c.name\n      FROM postgres_db.public.orders o\n      INNER JOIN analytics.customers c ON o.customer_id = c.id\n      WHERE o.status = \'completed\'  -- Filter early\n      LIMIT 10000  -- Prevent massive result sets\n    """\n  )\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n{\n  id: Int!\n  total: Float!\n  name: String!\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduces data processed by DuckDB"}),"\n",(0,r.jsx)(n.li,{children:"Improves query execution time"}),"\n",(0,r.jsx)(n.li,{children:"Prevents memory issues"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"7-test-extensions-incrementally",children:"7. Test Extensions Incrementally"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Start with simple extensions (single join)"}),"\n",(0,r.jsx)(n.li,{children:"Test each dependency separately"}),"\n",(0,r.jsx)(n.li,{children:"Gradually add complexity"}),"\n",(0,r.jsx)(n.li,{children:"Monitor performance at each step"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-data-enrichment",children:"Pattern 1: Data Enrichment"}),"\n",(0,r.jsx)(n.p,{children:"Extend operational data with analytics:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend type pg_products\n  @dependency(name: "postgres_db")  # Source of pg_products\n  @dependency(name: "analytics")    # Source of analytics functions and reviews\n{\n  sales_velocity: Float @function_call(\n    references_name: "calculate_sales_velocity"\n    module: "analytics"\n    args: { product_id: "id" }\n  )\n\n  customer_reviews: [mysql_reviews] @join(\n    references_name: "mysql_reviews"\n    source_fields: ["id"]\n    references_fields: ["product_id"]\n  )\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-unified-reporting",children:"Pattern 2: Unified Reporting"}),"\n",(0,r.jsx)(n.p,{children:"Create views combining multiple sources:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type unified_customer_360\n  @view(sql: """\n    SELECT\n      c.id,\n      c.name,\n      COUNT(DISTINCT o.id) as order_count,\n      SUM(s.page_views) as total_page_views,\n      MAX(i.last_interaction) as last_interaction\n    FROM postgres_db.public.customers c\n    LEFT JOIN postgres_db.public.orders o ON c.id = o.customer_id\n    LEFT JOIN analytics.sessions s ON c.email = s.user_email\n    LEFT JOIN crm.interactions i ON c.id = i.customer_id\n    GROUP BY c.id, c.name\n  """)\n  @dependency(name: "postgres_db")\n  @dependency(name: "analytics")\n  @dependency(name: "crm")\n{\n  id: Int!\n  name: String!\n  order_count: Int!\n  total_page_views: Int\n  last_interaction: Timestamp\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-federated-aggregation",children:"Pattern 3: Federated Aggregation"}),"\n",(0,r.jsx)(n.p,{children:"Aggregate data across sources:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  postgres_db {\n    pg_products {\n      id\n      name\n      # Sales from PostgreSQL\n      _join(fields: ["id"]) {\n        pg_sales_aggregation(fields: ["product_id"]) {\n          total_revenue: revenue { sum }\n        }\n      }\n      # Reviews from MySQL\n      _join(fields: ["id"]) {\n        mysql_reviews_aggregation(fields: ["product_id"]) {\n          avg_rating: rating { avg }\n          review_count: _rows_count\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"error-dependency-not-loaded",children:'Error: "Dependency not loaded"'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Referenced data source is not loaded or disabled."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check data source status in admin UI"}),"\n",(0,r.jsx)(n.li,{children:"Ensure dependent source is loaded before extension"}),"\n",(0,r.jsx)(n.li,{children:"Verify dependency names match exactly"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-type-not-found",children:'Error: "Type not found"'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Incorrect type name or missing prefix."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Verify type prefix matches data source configuration"}),"\n",(0,r.jsx)(n.li,{children:"Check type exists in referenced data source"}),"\n",(0,r.jsx)(n.li,{children:"Ensure dependency is declared"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-circular-dependency-detected",children:'Error: "Circular dependency detected"'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Two or more extensions depend on each other."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Review extension dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Reorganize schemas to eliminate circular references"}),"\n",(0,r.jsx)(n.li,{children:"Consider merging related extensions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symptoms"}),": Slow cross-source queries."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Add filters to reduce data volume"}),"\n",(0,r.jsx)(n.li,{children:"Use aggregations instead of fetching all records"}),"\n",(0,r.jsx)(n.li,{children:"Create indexed views for common queries"}),"\n",(0,r.jsx)(n.li,{children:"Consider materializing frequently-used cross-source data"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/data-sources/",children:"Data Sources"})," - Overview of all data source types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/data-sources/extension",children:"Extension Data Source"})," - Extension setup guide"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/graphql/queries/dynamic-joins",children:"Dynamic Joins (_join)"})," - Detailed documentation on dynamic joins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/graphql/queries/spatial",children:"Spatial Queries (_spatial)"})," - Spatial query documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/schema-definition/data-objects/joins",children:"Joins and Relations"})," - Schema-level join definitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/schema-definition/data-objects/function-calls",children:"Function Calls"})," - Function call field documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/schema-definition/data-objects/views",children:"Views"})," - SQL view documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/engine-configuration/schema-definition/modules",children:"Modules"})," - Module organization"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);