"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8172],{8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},9463:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"engine-configuration/schema-definition/data-objects/special-types","title":"Special Table Types","description":"Hugr provides special table type annotations for optimized handling of specific data patterns like OLAP cubes and time-series data.","source":"@site/docs/4-engine-configuration/3-schema-definition/3-data-objects/10-special-types.md","sourceDirName":"4-engine-configuration/3-schema-definition/3-data-objects","slug":"/engine-configuration/schema-definition/data-objects/special-types","permalink":"/docs/engine-configuration/schema-definition/data-objects/special-types","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/4-engine-configuration/3-schema-definition/3-data-objects/10-special-types.md","tags":[],"version":"current","lastUpdatedBy":"vgsml","lastUpdatedAt":1756711778000,"sidebarPosition":10,"frontMatter":{"title":"Special Table Types","sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"Function Calls","permalink":"/docs/engine-configuration/schema-definition/data-objects/function-calls"},"next":{"title":"Field Transformations and Additional Fields","permalink":"/docs/engine-configuration/schema-definition/data-objects/field-transformations"}}');var t=i(4848),a=i(8453);const r={title:"Special Table Types",sidebar_position:10},l="Special Table Types",c={},o=[{value:"Cubes with @cube",id:"cubes-with-cube",level:2},{value:"Querying Cubes",id:"querying-cubes",level:3},{value:"Measurement Aggregation Functions",id:"measurement-aggregation-functions",level:3},{value:"Cube Behavior",id:"cube-behavior",level:3},{value:"Mixed Queries",id:"mixed-queries",level:3},{value:"TimescaleDB Hypertables",id:"timescaledb-hypertables",level:2},{value:"Time-Series Queries",id:"time-series-queries",level:3},{value:"Continuous Aggregates",id:"continuous-aggregates",level:3},{value:"Combining Special Types",id:"combining-special-types",level:2},{value:"Performance Benefits",id:"performance-benefits",level:2},{value:"Cube Benefits",id:"cube-benefits",level:3},{value:"Hypertable Benefits",id:"hypertable-benefits",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"When to Use @cube",id:"when-to-use-cube",level:3},{value:"When to Use @hypertable",id:"when-to-use-hypertable",level:3},{value:"Combining with Other Features",id:"combining-with-other-features",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Cube Limitations",id:"cube-limitations",level:3},{value:"Hypertable Limitations",id:"hypertable-limitations",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"special-table-types",children:"Special Table Types"})}),"\n",(0,t.jsx)(n.p,{children:"Hugr provides special table type annotations for optimized handling of specific data patterns like OLAP cubes and time-series data."}),"\n",(0,t.jsx)(n.h2,{id:"cubes-with-cube",children:"Cubes with @cube"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@cube"})," directive enables OLAP-style pre-aggregation for analytical queries:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'type sales @table(name: "sales") @cube {\n  id: BigInt! @pk\n  \n  # Dimension fields (used for grouping)\n  customer_id: Int!\n  product_id: Int!\n  store_id: Int!\n  sale_date: Date!\n  \n  # Measurement fields (aggregated)\n  quantity: Int! @measurement\n  unit_price: Float! @measurement\n  total_amount: Float! @measurement\n  discount: Float! @measurement\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"querying-cubes",children:"Querying Cubes"}),"\n",(0,t.jsx)(n.p,{children:"When querying cubes, specify aggregation functions for measurements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sales {\n    # Dimensions (grouped by)\n    sale_date(bucket: month)\n    customer {\n      country\n    }\n    product {\n      category {\n        name\n      }\n    }\n    \n    # Measurements (aggregated)\n    quantity(measurement_func: SUM)\n    total_amount(measurement_func: SUM)\n    unit_price(measurement_func: AVG)\n    discount(measurement_func: AVG)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"measurement-aggregation-functions",children:"Measurement Aggregation Functions"}),"\n",(0,t.jsx)(n.p,{children:"Available functions by type:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Numeric (Int, BigInt, Float):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SUM"})," - Total sum"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AVG"})," - Average value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MIN"})," - Minimum value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MAX"})," - Maximum value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ANY"})," - Any value (for dimensions)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Boolean:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ANY"})," - Any value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"OR"})," - Logical OR"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AND"})," - Logical AND"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Date/Timestamp:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MIN"})," - Earliest date"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MAX"})," - Latest date"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ANY"})," - Any value"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cube-behavior",children:"Cube Behavior"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pre-aggregation"}),": Data is grouped before joins"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic dimensions"}),": Non-measurement fields become group-by dimensions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subquery impact"}),": Adding related fields automatically includes foreign keys in grouping"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example with automatic dimension inclusion:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sales {\n    # customer_id automatically included in GROUP BY\n    customer {\n      name\n      country\n    }\n    \n    # Aggregations\n    total_amount(measurement_func: SUM)\n    quantity(measurement_func: SUM)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mixed-queries",children:"Mixed Queries"}),"\n",(0,t.jsx)(n.p,{children:"Combine measurements with and without aggregation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sales {\n    # Dimensions\n    sale_date(bucket: quarter)\n    store_id\n    \n    # Aggregated measurement\n    total_revenue: total_amount(measurement_func: SUM)\n    \n    # Non-aggregated (becomes dimension)\n    unit_price\n    \n    # Count of records\n    _rows_count\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"timescaledb-hypertables",children:"TimescaleDB Hypertables"}),"\n",(0,t.jsx)(n.p,{children:"For PostgreSQL with TimescaleDB, optimize time-series data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'type sensor_readings @table(name: "sensor_readings") @hypertable {\n  sensor_id: Int! @pk\n  timestamp: Timestamp! @pk @timescale_key\n  temperature: Float!\n  humidity: Float!\n  pressure: Float!\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"time-series-queries",children:"Time-Series Queries"}),"\n",(0,t.jsx)(n.p,{children:"Leverage TimescaleDB functions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sensor_readings_bucket_aggregation {\n    key {\n      # TimescaleDB time_bucket function\n      timestamp(bucket: hour)\n      sensor_id\n    }\n    aggregations {\n      temperature {\n        avg\n        min\n        max\n      }\n      humidity {\n        avg\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"continuous-aggregates",children:"Continuous Aggregates"}),"\n",(0,t.jsx)(n.p,{children:"Define views on hypertables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'type hourly_sensor_stats @view(\n  name: "hourly_sensor_stats"\n) @hypertable {\n  sensor_id: Int! @pk\n  hour: Timestamp! @pk @timescale_key\n  avg_temperature: Float!\n  avg_humidity: Float!\n  min_temperature: Float!\n  max_temperature: Float!\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"combining-special-types",children:"Combining Special Types"}),"\n",(0,t.jsx)(n.p,{children:"Use cubes with time-series data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'type sales_metrics @table(name: "sales_metrics") \n  @cube \n  @hypertable {\n  \n  # Time dimension\n  timestamp: Timestamp! @timescale_key\n  \n  # Other dimensions\n  product_id: Int!\n  region: String!\n  \n  # Measurements\n  revenue: Float! @measurement\n  units_sold: Int! @measurement\n  customers: Int! @measurement\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Query with time-series optimization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sales_metrics {\n    # Time bucket using TimescaleDB\n    timestamp(bucket: day)\n    \n    # Dimension\n    region\n    \n    # Aggregated measurements\n    revenue(measurement_func: SUM)\n    units_sold(measurement_func: SUM)\n    customers(measurement_func: COUNT)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-benefits",children:"Performance Benefits"}),"\n",(0,t.jsx)(n.h3,{id:"cube-benefits",children:"Cube Benefits"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced computation"}),": Pre-aggregation before joins"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimized grouping"}),": Automatic dimension detection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory efficiency"}),": Less data transferred"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hypertable-benefits",children:"Hypertable Benefits"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic partitioning"}),": By time dimension"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Faster queries"}),": Optimized for time-range queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data compression"}),": Automatic old data compression"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Continuous aggregates"}),": Materialized time-based views"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-cube",children:"When to Use @cube"}),"\n",(0,t.jsx)(n.p,{children:"Use for tables that are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Frequently aggregated"}),"\n",(0,t.jsx)(n.li,{children:"Have clear dimensions vs measurements"}),"\n",(0,t.jsx)(n.li,{children:"Used in analytical/reporting queries"}),"\n",(0,t.jsx)(n.li,{children:"Large fact tables in star/snowflake schemas"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-hypertable",children:"When to Use @hypertable"}),"\n",(0,t.jsx)(n.p,{children:"Use for tables that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Have time-series data"}),"\n",(0,t.jsx)(n.li,{children:"Are partitioned by time"}),"\n",(0,t.jsx)(n.li,{children:"Need efficient time-range queries"}),"\n",(0,t.jsx)(n.li,{children:"Require automatic data retention policies"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"combining-with-other-features",children:"Combining with Other Features"}),"\n",(0,t.jsx)(n.p,{children:"Cubes and hypertables work with all other Hugr features:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'type sales @table(name: "sales") \n  @cube \n  @cache(ttl: 300, tags: ["sales"]) {\n  \n  id: BigInt! @pk\n  store_id: Int! @field_references(\n    references_name: "stores"\n    field: "id"\n    query: "store"\n  )\n  sale_date: Date!\n  amount: Float! @measurement\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Query with relations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query {\n  sales {\n    sale_date(bucket: month)\n    store {\n      region\n      country\n    }\n    amount(measurement_func: SUM)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.h3,{id:"cube-limitations",children:"Cube Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pre-aggregation happens before joins"}),"\n",(0,t.jsx)(n.li,{children:"Cannot mix aggregated and non-aggregated measurements"}),"\n",(0,t.jsx)(n.li,{children:"All non-measurement fields become dimensions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hypertable-limitations",children:"Hypertable Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Requires PostgreSQL with TimescaleDB"}),"\n",(0,t.jsx)(n.li,{children:"Primary key must include time column"}),"\n",(0,t.jsx)(n.li,{children:"Some constraints not supported on distributed hypertables"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);