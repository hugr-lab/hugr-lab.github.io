"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[7178],{7519:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"engine-configuration/data-sources/postgres","title":"PostgreSQL","description":"PostgreSQL data source configuration and usage in Hugr engine. Includes query push-down, range types, PostGIS, and TimescaleDB support.","source":"@site/docs/4-engine-configuration/1-data-sources/2-postgres.md","sourceDirName":"4-engine-configuration/1-data-sources","slug":"/engine-configuration/data-sources/postgres","permalink":"/docs/engine-configuration/data-sources/postgres","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/4-engine-configuration/1-data-sources/2-postgres.md","tags":[],"version":"current","lastUpdatedBy":"vgsml","lastUpdatedAt":1749506002000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"PostgreSQL","description":"PostgreSQL data source configuration and usage in Hugr engine. Includes query push-down, range types, PostGIS, and TimescaleDB support."},"sidebar":"docsSidebar","previous":{"title":"DuckDB","permalink":"/docs/engine-configuration/data-sources/duckdb"},"next":{"title":"MySQL","permalink":"/docs/engine-configuration/data-sources/mysql"}}');var a=n(4848),o=n(8453);const i={sidebar_position:2,title:"PostgreSQL",description:"PostgreSQL data source configuration and usage in Hugr engine. Includes query push-down, range types, PostGIS, and TimescaleDB support."},r=void 0,d={},c=[{value:"Setting up PostgreSQL data source",id:"setting-up-postgresql-data-source",level:2},{value:"PostgreSQL schema definition",id:"postgresql-schema-definition",level:2},{value:"Query push-downing",id:"query-push-downing",level:2},{value:"Range data types support",id:"range-data-types-support",level:2},{value:"PostGIS support",id:"postgis-support",level:2},{value:"TimescaleDB support",id:"timescaledb-support",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Example",id:"example",level:2}];function l(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"The PostgreSQL data source allows you to connect to a PostgreSQL database. It can be used to access and manipulate data stored in PostgreSQL tables and views."}),"\n",(0,a.jsx)(s.p,{children:"The PostgreSQL data source is a powerful feature of the Hugr engine, allowing you to leverage the capabilities of PostgreSQL, including query push-down, range data types, PostGIS support, and TimescaleDB support. You can use it to rapid develop a data backend for your applications and services, while taking advantage of the rich features of PostgreSQL."}),"\n",(0,a.jsx)(s.p,{children:"As well PostgreSQL with TimescaleDB, PostGIS and pg_duckdb extensions can be used as a data data warehouse, and hugr can be used as data access layer for your data warehouse, providing a unified GraphQL API for your data."}),"\n",(0,a.jsx)(s.h2,{id:"setting-up-postgresql-data-source",children:"Setting up PostgreSQL data source"}),"\n",(0,a.jsxs)(s.p,{children:["To set up a PostgreSQL data source you need to add data source record to the ",(0,a.jsx)(s.code,{children:"data_sources"})," table through the GraphQL API."]}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"path"})," should contain PostgreSQL connection string (e.g. ",(0,a.jsx)(s.code,{children:"postgres://user:password@host:port/database?param=val"}),"). The path can also contain envinronment variables, for example ",(0,a.jsx)(s.code,{children:"postgres://user:password@host:port/[$HUGR_DB_NAME]"}),". When the data source are being attached to the Hugr engine, the environment variables will be replaced with the actual values."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-graphql",children:"mutation addPostgresDataSet($data: data_sources_mut_input_data! = {}) {\n  core {\n    insert_data_sources(data: $data) {\n      name\n      description\n      as_module\n      disabled\n      path\n      prefix\n      read_only\n      self_defined\n      type\n      catalogs {\n        name\n        description\n        path\n        type\n      }\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"Variables:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-json",children:'{\n  "data": {\n    "name": "pg",\n    "type": "postgres",\n    "connection_string": "postgres://user:password@host:port/database",\n    "prefix": "ds1",\n    "description": "My PostgreSQL data set",\n    "read_only": false,\n    "self_defined": false,\n    "as_module": true,\n    "disabled": false,\n    "catalogs": [\n      {\n        "name": "pg_catalog",\n        "description": "My PostgreSQL catalog source",\n        "path": "s3://my-bucket/pg-catalog/",\n        "type": "uri"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsx)(s.h2,{id:"postgresql-schema-definition",children:"PostgreSQL schema definition"}),"\n",(0,a.jsxs)(s.p,{children:["As the database source the PostgreSQL data source can be marked as ",(0,a.jsx)(s.code,{children:"read_only"})," or ",(0,a.jsx)(s.code,{children:"self_defined"}),". The ",(0,a.jsx)(s.code,{children:"read_only"})," means that the data source is read-only and its data cannot be modified. The ",(0,a.jsx)(s.code,{children:"self_defined"})," means that the data source is self-defined and the GraphQL schema definition will be generated base on the Tables and Views metadata."]}),"\n",(0,a.jsx)(s.p,{children:"You can also add a number of catalogs to the PostgreSQL data source. All data source catalogs will be merged into one catalog, as well with the self-defined generated definitions."}),"\n",(0,a.jsx)(s.h2,{id:"query-push-downing",children:"Query push-downing"}),"\n",(0,a.jsxs)(s.p,{children:["The PostgreSQL data source in ",(0,a.jsx)(s.code,{children:"hugr"})," supports query push-down to the PostgreSQL database. This means that the ",(0,a.jsx)(s.code,{children:"hugr"})," engine will try to push down all parts of the query:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Filters (",(0,a.jsx)(s.code,{children:"WHERE"})," clauses)"]}),"\n",(0,a.jsxs)(s.li,{children:["Sorting (",(0,a.jsx)(s.code,{children:"ORDER BY"})," clauses)"]}),"\n",(0,a.jsxs)(s.li,{children:["Pagination (",(0,a.jsx)(s.code,{children:"LIMIT"})," and ",(0,a.jsx)(s.code,{children:"OFFSET"})," clauses)"]}),"\n",(0,a.jsxs)(s.li,{children:["Aggregations (",(0,a.jsx)(s.code,{children:"GROUP BY"})," clauses and aggregate functions like ",(0,a.jsx)(s.code,{children:"COUNT"}),", ",(0,a.jsx)(s.code,{children:"SUM"}),", ",(0,a.jsx)(s.code,{children:"AVG"}),", etc.)"]}),"\n",(0,a.jsxs)(s.li,{children:["Joins between tables and views (",(0,a.jsx)(s.code,{children:"JOIN"})," clauses)"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"This allows the PostgreSQL database to handle the query execution, which can significantly improve performance for large datasets."}),"\n",(0,a.jsxs)(s.p,{children:["Because the ",(0,a.jsx)(s.code,{children:"hugr"})," supports schema extensions and query-time joins and spatial queries, it can be so when the subquery it self contain joins with other data source data objects, in this case only filters, sorting and pagination can be pushed down."]}),"\n",(0,a.jsx)(s.h2,{id:"range-data-types-support",children:"Range data types support"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"hugr"})," supports PostgreSQL range types, which allow you to represent a range of values in a single column. You can use the following types in your schema definitions to work with range data:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"IntRange"}),": Represents a range of 4 bytes integers."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"BigIntRange"}),": Represents a range of 8 bytes integers."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"TimestampRange"}),": Represents a range of timestamps."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"postgis-support",children:"PostGIS support"}),"\n",(0,a.jsxs)(s.p,{children:["The PostgreSQL data source also supports PostGIS, which is a spatial database extender for PostgreSQL. If you have PostGIS installed in your PostgreSQL database, you can use spatial queries and functions in your ",(0,a.jsx)(s.code,{children:"hugr"})," queries."]}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"hugr"})," defines special scalar type ",(0,a.jsx)(s.code,{children:"geometry"})," to represent both geometry and geography PostGIS types. You can use this type in your schema definitions to work with spatial data."]}),"\n",(0,a.jsx)(s.h2,{id:"timescaledb-support",children:"TimescaleDB support"}),"\n",(0,a.jsxs)(s.p,{children:["The PostgreSQL data source supports TimescaleDB, which is a time-series database built on top of PostgreSQL. If you have TimescaleDB installed in your PostgreSQL database, you can use time-series queries and functions in your ",(0,a.jsx)(s.code,{children:"hugr"})," queries."]}),"\n",(0,a.jsxs)(s.p,{children:["You can use special ",(0,a.jsx)(s.code,{children:"@hypertable"})," directive in table definitions to mark a table as a TimescalleDB hypertable and mark Timestamp column ",(0,a.jsx)(s.code,{children:"timescale_key"})," to use time-series functions (time buckets)."]}),"\n",(0,a.jsx)(s.h2,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsxs)(s.p,{children:["The PostgreSQL auto-generated schema (when ",(0,a.jsx)(s.code,{children:"self_defined"})," is set to ",(0,a.jsx)(s.code,{children:"true"}),") has following limitations:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Only tables and views are supported. The functions are not supported."}),"\n",(0,a.jsx)(s.li,{children:"All views are generated as tables, so you can query them as tables, but also will be generated data mutation operations for them."}),"\n",(0,a.jsx)(s.li,{children:"Relationships are not generated for the tables and views. You can define them manually in the catalog files."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["So, practically, we don't recommend to use the PostgreSQL data source with ",(0,a.jsx)(s.code,{children:"self_defined"})," set to ",(0,a.jsx)(s.code,{children:"true"})," for the production usage, but it can be used for the schema development - you can get auto-generated schema with following function call after the data source added and attached to the Hugr engine:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-graphql",children:'query schema{\n  function{\n    core{\n      describe_data_source_schema(name: "pg", self: true)\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(s.p,{children:"It will return the schema definition GraphQL string, that you can use to create the catalog file for the data source."}),"\n",(0,a.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["PostgreSQL data source example with the Northwind database: ",(0,a.jsx)(s.a,{href:"/docs/examples/postgres-get-started",children:"Get Started with PostgreSQL"})]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>r});var t=n(6540);const a={},o=t.createContext(a);function i(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);