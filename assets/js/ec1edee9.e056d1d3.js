"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[5258],{6341:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"engine-configuration/schema-definition/data-types","title":"Data Types","description":"Understanding the data types supported by Hugr","source":"@site/docs/4-engine-configuration/3-schema-definition/1-data-types.md","sourceDirName":"4-engine-configuration/3-schema-definition","slug":"/engine-configuration/schema-definition/data-types","permalink":"/docs/engine-configuration/schema-definition/data-types","draft":false,"unlisted":false,"editUrl":"https://github.com/hugr-lab/hugr-lab.github.io/docs/4-engine-configuration/3-schema-definition/1-data-types.md","tags":[],"version":"current","lastUpdatedBy":"vgsml","lastUpdatedAt":1759235264000,"sidebarPosition":2,"frontMatter":{"title":"Data Types","sidebar_position":2,"description":"Understanding the data types supported by Hugr"},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/docs/docs/4-engine-configuration/3-schema-definition"},"next":{"title":"Functions","permalink":"/docs/engine-configuration/schema-definition/function"}}');var l=i(4848),t=i(8453);const r={title:"Data Types",sidebar_position:2,description:"Understanding the data types supported by Hugr"},c=void 0,d={},a=[{value:"String",id:"string",level:2},{value:"Filter operations",id:"filter-operations",level:3},{value:"Aggregation functions",id:"aggregation-functions",level:3},{value:"Subaggregation functions",id:"subaggregation-functions",level:3},{value:"Boolean",id:"boolean",level:2},{value:"Filter operations",id:"filter-operations-1",level:3},{value:"Aggregation functions",id:"aggregation-functions-1",level:3},{value:"Subaggregation functions",id:"subaggregation-functions-1",level:3},{value:"Numbers - Int, BigInt and Float",id:"numbers---int-bigint-and-float",level:2},{value:"Filter operations",id:"filter-operations-2",level:3},{value:"Aggregation functions",id:"aggregation-functions-2",level:3},{value:"Subaggregation functions",id:"subaggregation-functions-2",level:3},{value:"DateTime types - Date, Time, TimeStamp",id:"datetime-types---date-time-timestamp",level:2},{value:"Generated arguments",id:"generated-arguments",level:3},{value:"Calculated fields",id:"calculated-fields",level:3},{value:"Filters",id:"filters",level:3},{value:"Aggregation functions",id:"aggregation-functions-3",level:3},{value:"Subaggregation functions",id:"subaggregation-functions-3",level:3},{value:"Interval",id:"interval",level:2},{value:"Filter operations",id:"filter-operations-3",level:3},{value:"Range types",id:"range-types",level:2},{value:"Filter operations",id:"filter-operations-4",level:3},{value:"JSON",id:"json",level:2},{value:"Generated arguments",id:"generated-arguments-1",level:3},{value:"Filters",id:"filters-1",level:3},{value:"Aggregation functions",id:"aggregation-functions-4",level:3},{value:"Subaggregation functions",id:"subaggregation-functions-4",level:3},{value:"Geometry",id:"geometry",level:2},{value:"Generated arguments",id:"generated-arguments-2",level:3},{value:"Calculated fields",id:"calculated-fields-1",level:3},{value:"Filter operations",id:"filter-operations-5",level:2},{value:"Aggregation functions",id:"aggregation-functions-5",level:3},{value:"Subaggregation functions",id:"subaggregation-functions-5",level:3},{value:"Vector",id:"vector",level:2},{value:"Calculated fields",id:"calculated-fields-2",level:3},{value:"Filter operations",id:"filter-operations-6",level:3},{value:"Aggregation functions",id:"aggregation-functions-6",level:3},{value:"Vector similarity search",id:"vector-similarity-search",level:3},{value:"List types",id:"list-types",level:2},{value:"Filter operations",id:"filter-operations-7",level:3}];function o(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Hugr supports the following scalar data types:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:"# Base GraphQL Scalar Types\nscalar String\nscalar Int\nscalar Float\nscalar Boolean\n\n# Additional Hugr Scalar Types\nscalar BigInt\nscalar Timestamp\nscalar Date\nscalar Time\nscalar Interval \nscalar Geometry \nscalar JSON \nscalar H3Cell\n\n# Range Types that can be used only for PostgreSQL data sources\nscalar IntRange \nscalar TimestampRange\nscalar BigIntRange\n\nscalar any\n\n# Represents a vector type for embedding and similarity search. For PostgreSQL data sources, it maps to the `vector` type. For duckdb data sources, it maps to the `FLOAT[]` type.\nscalar Vector\n"})}),"\n",(0,l.jsx)(n.p,{children:"These types can be used:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"as parameters and arguments in functions"}),"\n",(0,l.jsx)(n.li,{children:"as column types in tables and views"}),"\n",(0,l.jsx)(n.li,{children:"as input argument fields in parameterized views\nHugr automatically generates queries and mutations for tables and views based on the defined field data types. The available filter operations, aggregation functions, and calculated fields depend on these data types. Hugr also supports subaggregations for aggregated subquery fields."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For certain fields in the generated queries, arguments can be provided to transform the data. Additionally, Hugr may include extra calculated fields according to the defined data types."}),"\n",(0,l.jsx)(n.h2,{id:"string",children:"String"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"String"})," type is used to represent textual data.\nInput values must be Unicode."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the string is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"in"})," - Checks if the string is in a specified list of values."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"like"})," - Checks if the string matches a specified pattern (as wildcard ",(0,l.jsx)(n.code,{children:"%"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ilike"})," - Checks if the string matches a specified pattern (case-insensitive)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regex"})," - Checks if the string matches a specified regular expression."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the string is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"string_agg"})," - Concatenates strings with a separator; separator and distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list"})," - Returns a list of values; distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any"})," - Returns any non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last"})," - Returns the last non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"string_agg"})," - Concatenates the aggregated array of strings with the same separator as specified for the aggregation function"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"boolean",children:"Boolean"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Boolean"})," type is used to represent true/false values. Input values must be either ",(0,l.jsx)(n.code,{children:"true"})," or ",(0,l.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-1",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the boolean is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the boolean is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-1",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_and"})," - Returns true if all non-null values are true"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_or"})," - Returns true if any non-null value is true"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list(distinct: Boolean = false): [Boolean!]"})," - Returns a list of values; distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any"})," - Returns any non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last"})," - Returns the last non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions-1",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_and"})," - Returns true if all non-null values are true"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_or"})," - Returns true if any non-null value is true"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"numbers---int-bigint-and-float",children:"Numbers - Int, BigInt and Float"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Int"}),", ",(0,l.jsx)(n.code,{children:"BigInt"}),", and ",(0,l.jsx)(n.code,{children:"Float"})," types are used to represent numeric values. Input values must be valid numbers with ",(0,l.jsx)(n.code,{children:"."})," as the decimal separator."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-2",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the number is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gt"})," - Checks if the number is greater than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gte"})," - Checks if the number is greater than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lt"})," - Checks if the number is less than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lte"})," - Checks if the number is less than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"in"})," - Checks if the number is in a specified list of values."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the number is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-2",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sum"})," - Calculates the sum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"avg"})," - Calculates the average of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min"})," - Finds the minimum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max"})," - Finds the maximum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list(distinct: Boolean = false)"})," - Returns a list of values; distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any"})," - Returns any non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last"})," - Returns the last non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions-2",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - Calculates the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sum"})," - Calculates the sum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"avg"})," - Calculates the average of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min"})," - Finds the minimum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max"})," - Finds the maximum non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"datetime-types---date-time-timestamp",children:"DateTime types - Date, Time, TimeStamp"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"DateTime"})," types are used to represent date and time values.\nDate values must be in the format ",(0,l.jsx)(n.code,{children:"YYYY-MM-DD"}),".\nTime values must be in the format ",(0,l.jsx)(n.code,{children:"HH:MM:SS"}),".\nTimestamp values can be in the format ",(0,l.jsx)(n.code,{children:"YYYY-MM-DDTHH:MM:SSZ07:00"})," or as UnixTime (",(0,l.jsx)(n.code,{children:"BigInt"}),")."]}),"\n",(0,l.jsx)(n.h3,{id:"generated-arguments",children:"Generated arguments"}),"\n",(0,l.jsxs)(n.p,{children:["For the ",(0,l.jsx)(n.code,{children:"Date"})," and ",(0,l.jsx)(n.code,{children:"Timestamp"})," fields, the ",(0,l.jsx)(n.code,{children:"bucket"})," argument will be generated. If the ",(0,l.jsx)(n.code,{children:"bucket"})," argument is present, it will be used to transform the data into the specified time bucket. The following values are accepted:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"minute"}),"\n",(0,l.jsx)(n.li,{children:"hour"}),"\n",(0,l.jsx)(n.li,{children:"day"}),"\n",(0,l.jsx)(n.li,{children:"week"}),"\n",(0,l.jsx)(n.li,{children:"month"}),"\n",(0,l.jsx)(n.li,{children:"quarter"}),"\n",(0,l.jsx)(n.li,{children:"year"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["For the ",(0,l.jsx)(n.code,{children:"Timestamp"})," fields, the ",(0,l.jsx)(n.code,{children:"bucket_interval"})," argument will be generated; it accepts Interval values. If the ",(0,l.jsx)(n.code,{children:"bucket_interval"})," argument is present, it will be used to transform the data into the specified time interval.\nFor example, ",(0,l.jsx)(n.code,{children:'bucket_interval: "15 minutes"'}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'"2025-08-25T12:03:00Z02:00" -> "2025-08-25T12:00:00Z02:00"'}),"\n",(0,l.jsx)(n.li,{children:'"2025-08-25T12:16:00Z02:00" -> "2025-08-25T12:15:00Z02:00"'}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"calculated-fields",children:"Calculated fields"}),"\n",(0,l.jsxs)(n.p,{children:["For each ",(0,l.jsx)(n.code,{children:"Date"})," and ",(0,l.jsx)(n.code,{children:"Timestamp"})," table or view field, a new field will be generated with the name: ",(0,l.jsx)(n.code,{children:"_<field_name>_part"}),", type ",(0,l.jsx)(n.code,{children:"BigInt"}),", and the following parameters:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extract"})," - The part of the date or timestamp to extract. Possible values are: epoch, minute, hour, day, doy, dow, iso_dow, week, month, year, iso_year, quarter."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extract_divide"})," - The divider for the extracted part."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"filters",children:"Filters"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the value is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gt"})," - Checks if the value is greater than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gte"})," - Checks if the value is greater than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lt"})," - Checks if the value is less than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lte"})," - Checks if the value is less than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the value is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-3",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - calculate the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min"})," - find the minimum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max"})," - find the maximum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list(distinct: Boolean = false)"})," - return a list of values, distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any"})," - return any non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last"})," - return the last non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions-3",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"})," - calculate the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min"})," - find the minimum non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max"})," - find the maximum non-null value"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"interval",children:"Interval"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Interval"})," type is used to represent a time duration. Interval types can only be used in filter operations.\nInput values must be in the format ",(0,l.jsx)(n.code,{children:"quantity unit"}),", where ",(0,l.jsx)(n.code,{children:"quantity"})," is a number and ",(0,l.jsx)(n.code,{children:"unit"})," is one of the following: microseconds, milliseconds, seconds, minutes, hours, days, weeks, months, quarters, years. For example: ",(0,l.jsx)(n.code,{children:"5 days 12 hours"}),", ",(0,l.jsx)(n.code,{children:"2 hours"}),", ",(0,l.jsx)(n.code,{children:"30 minutes"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-3",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the value is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gt"})," - Checks if the value is greater than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gte"})," - Checks if the value is greater than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lt"})," - Checks if the value is less than a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lte"})," - Checks if the value is less than or equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the value is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"range-types",children:"Range types"}),"\n",(0,l.jsx)(n.p,{children:"The range types represent PostgreSQL range types. The following range data types are supported:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"int4range"})," - Represents a range of 4-byte integers (",(0,l.jsx)(n.code,{children:"IntRange"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"int8range"})," - Represents a range of 8-byte integers (",(0,l.jsx)(n.code,{children:"BigIntRange"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"tsrange"})," - Represents a range of timestamps (",(0,l.jsx)(n.code,{children:"TimestampRange"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"tstzrange"})," - Represents a range of timestamp with time zone (",(0,l.jsx)(n.code,{children:"TimestampRange"}),")."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Range types can only be used in filtering operations.\nInput values must be a string in the format ",(0,l.jsx)(n.code,{children:'"[lower, upper]"'}),", where ",(0,l.jsx)(n.code,{children:"lower"})," and ",(0,l.jsx)(n.code,{children:"upper"})," are the bounds of the range. The bounds can be inclusive or exclusive, denoted by ",(0,l.jsx)(n.code,{children:"["})," or ",(0,l.jsx)(n.code,{children:"("})," for the lower bound and ",(0,l.jsx)(n.code,{children:"]"})," or ",(0,l.jsx)(n.code,{children:")"})," for the upper bound. For example: ",(0,l.jsx)(n.code,{children:'"[1, 10]"'}),", ",(0,l.jsx)(n.code,{children:'"(1, 10]"'}),", ",(0,l.jsx)(n.code,{children:'"[2023-01-01T00:00:00Z, 2023-12-31T00:00:00Z]"'}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-4",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the value is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"contains"})," - Checks if the range contains a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intersects"})," - Checks if the range intersects with another range."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"includes"})," - Checks if the range includes another range."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the range is null."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"upper"})," - Checks if the upper bound of the range is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lower"})," - Checks if the lower bound of the range is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"upper_inclusive"})," - Checks if the upper bound of the range is included (",(0,l.jsx)(n.code,{children:"(1,2]"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lower_inclusive"})," - Checks if the lower bound of the range is included (",(0,l.jsx)(n.code,{children:"[1,2)"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"upper_inf"})," - Checks if the upper bound of the range is unbounded (",(0,l.jsx)(n.code,{children:"(1,\u221e)"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lower_inf"})," - Checks if the lower bound of the range is unbounded (",(0,l.jsx)(n.code,{children:"(-\u221e,2)"}),")."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"json",children:"JSON"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"JSON"})," type is used to represent JSON objects (for PostgreSQL JSONB). It can be used in various ways, including aggregation by a specified path."]}),"\n",(0,l.jsxs)(n.p,{children:["Input values should be in the format of a standard JSON object: ",(0,l.jsx)(n.code,{children:'{"key": "value"}'})]}),"\n",(0,l.jsx)(n.h3,{id:"generated-arguments-1",children:"Generated arguments"}),"\n",(0,l.jsxs)(n.p,{children:["For ",(0,l.jsx)(n.code,{children:"JSON"})," table or view fields, the ",(0,l.jsx)(n.code,{children:"struct"})," argument will be generated. This argument accepts a JSON object that defines the data structure, to extract only the necessary fields from the JSON field.\nFor example:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{"field1": "string", "field2": {"subfield": "int", "subfield2": ["float"]}}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The following data types are accepted:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"string"})," - GraphQL ",(0,l.jsx)(n.code,{children:"String"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"int"})," - GraphQL ",(0,l.jsx)(n.code,{children:"Int"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bigint"})," - GraphQL ",(0,l.jsx)(n.code,{children:"BigInt"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"float"})," - GraphQL ",(0,l.jsx)(n.code,{children:"Float"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"boolean"})," - GraphQL ",(0,l.jsx)(n.code,{children:"Boolean"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"time"})," - GraphQL ",(0,l.jsx)(n.code,{children:"Timestamp"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"json"})," - GraphQL ",(0,l.jsx)(n.code,{children:"JSON"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"h3String"})," - GraphQL ",(0,l.jsx)(n.code,{children:"String"})]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"filters-1",children:"Filters"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the value is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"has"})," - Checks if the JSON object has a specified key."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"has_all"})," - Checks if the JSON object has all specified keys."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"contains"})," - Checks if the JSON object contains a specified JSON value (works the same way as the operator ",(0,l.jsx)(n.code,{children:"@>"})," in PostgreSQL)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the JSON object is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-4",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count(path: String)"})," - calculate the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list(path: String, distinct: Boolean = false)"})," - return a list of values, distinct can be specified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any(path: String)"})," - return any non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last(path: String)"})," - return the last non-null value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sum(path: String!)"})," - calculate the sum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"avg(path: String!)"})," - calculate the average of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min(path: String!)"})," - calculate the minimum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max(path: String!)"})," - calculate the maximum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"string_agg(path: String!, sep: String!, distinct: Boolean = false)"})," - concatenate non-null values into a string"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_and(path: String!)"})," - calculate the boolean AND of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_or(path: String!)"})," - calculate the boolean OR of non-null values"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions-4",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count(path: String)"})," - calculate the number of non-null unique values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sum(path: String!)"})," - calculate the sum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"avg(path: String!)"})," - calculate the average of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min(path: String!)"})," - calculate the minimum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max(path: String!)"})," - calculate the maximum of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"string_agg(path: String!, sep: String!, distinct: Boolean = false)"})," - concatenate non-null values into a string"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_and(path: String!)"})," - calculate the boolean AND of non-null values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"bool_or(path: String!)"})," - calculate the boolean OR of non-null values"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"geometry",children:"Geometry"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Geometry"})," type is used to represent geometric shapes and can be used in various ways, including filtering and aggregation.\nThe input values for ",(0,l.jsx)(n.code,{children:"Geometry"})," can be:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"object - A GeoJSON object representing the geometry"}),"\n",(0,l.jsx)(n.li,{children:"string - A WKT (Well-Known Text) or WKB (Well-Known Binary) representation of the geometry"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"generated-arguments-2",children:"Generated arguments"}),"\n",(0,l.jsxs)(n.p,{children:["The following arguments are generated for ",(0,l.jsx)(n.code,{children:"Geometry"})," fields:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"transforms: [GeometryTransform]"})," - a list of transformations to apply to the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"from: Int"})," - the SRID to transform from"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"to: Int"})," - the SRID to transform to"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"buffer: Float"})," - the buffer distance to apply to the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"simplify_factor: Float"})," - the factor by which to simplify the geometry"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The valid types of transformation:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Transform"})," - reproject geometry to a different coordinate reference system (CRS); uses ",(0,l.jsx)(n.code,{children:"from"})," SRID and ",(0,l.jsx)(n.code,{children:"to"})," SRID"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Centroid"})," - calculate the centroid of the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Buffer"})," - create a buffer around the geometry; if geometry is in the EPSG:4326 CRS, the distance is in meters"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Simplify"})," - simplify the geometry; uses ",(0,l.jsx)(n.code,{children:"simplify_factor"})," to determine the level of simplification"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"SimplifyTopology"})," - simplify the geometry while preserving topology; uses ",(0,l.jsx)(n.code,{children:"simplify_factor"})," to determine the level of simplification"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"StartPoint"})," - get the start point of the geometry (for LineString)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"EndPoint"})," - get the end point of the geometry (for LineString)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Reverse"})," - reverse the geometry (for LineString)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FlipCoordinates"})," - flip the coordinates of the geometry."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ConvexHull"})," - get the convex hull of the geometry."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Envelope"})," - get the envelope of the geometry."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"calculated-fields-1",children:"Calculated fields"}),"\n",(0,l.jsxs)(n.p,{children:["For each ",(0,l.jsx)(n.code,{children:"Geometry"})," table or view field, a new field will be generated with the name: ",(0,l.jsx)(n.code,{children:"_<field_name>_measurement"}),", type ",(0,l.jsx)(n.code,{children:"Float"}),", and the following parameters:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"type: GeometryMeasurementTypes"})," - The type of measurement"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"transform: Boolean = False"})," - Whether to apply the transformations before calculating the measurement"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"from: Int"})," - The SRID to transform from"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"to: Int"})," - The SRID to transform to"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The following types of measurements are valid:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Area"})," - The area of the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"AreaSpheroid"})," - The area of the geometry on a spheroid in square meters"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Length"})," - The length of the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"LengthSpheroid"})," - The length of the geometry on a spheroid in meters"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Perimeter"})," - The perimeter of the geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"PerimeterSpheroid"})," - The perimeter of the geometry on a spheroid in meters"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"filter-operations-5",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the value is equal to a specified value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intersects"})," - Checks if the geometry intersects with another geometry."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"contains"})," - Checks if the geometry contains another geometry."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the geometry is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-5",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"}),": Calculates the number of non-null unique values."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"list(distinct: Boolean = false)"}),": Returns a list of values, distinct can be specified."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"any"}),": Returns any non-null value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"last"}),": Returns the last non-null value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intersection"}),": Returns the intersection of geometries."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"union"}),": Returns the union of geometries."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extent"}),": Returns the extent of geometries."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"subaggregation-functions-5",children:"Subaggregation functions"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"count"}),": Calculates the number of non-null unique values."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intersection"}),": Returns the intersection of geometries."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"union"}),": Returns the union of geometries."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extent"}),": Returns the extent of geometries."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"vector",children:"Vector"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Vector"})," type is used to represent vector embeddings for similarity search. It can used only in data objects (tables and views) to perform similarity searches. Currently, it is supported only for PostgreSQL (using ",(0,l.jsx)(n.code,{children:"vector"})," type and with the ",(0,l.jsx)(n.code,{children:"pgvector"})," extension) and DuckDB (using ",(0,l.jsx)(n.code,{children:"FLOAT[]"})," type and the ",(0,l.jsx)(n.code,{children:"vss"})," extension)."]}),"\n",(0,l.jsxs)(n.p,{children:["In filtering operations you can use only ",(0,l.jsx)(n.code,{children:"is_null"})," operation."]}),"\n",(0,l.jsx)(n.p,{children:"Input values can be formatted:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["as a JSON array of numbers: ",(0,l.jsx)(n.code,{children:"[0.1, 0.2, 0.3]"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["as a string (the same format as in the PostgreSQL vector representation): ",(0,l.jsx)(n.code,{children:"[0.1,0.2,0.3]"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The output format - string (the same format as in the PostgreSQL vector representation): ",(0,l.jsx)(n.code,{children:"[0.1,0.2,0.3]"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["If the ",(0,l.jsx)(n.code,{children:"Vector"})," type is used in a table or view, the ",(0,l.jsx)(n.code,{children:"@dim"})," directive can be applied to specify the dimensionality of the vector. For example, ",(0,l.jsx)(n.code,{children:"@dim(len: 768)"})," indicates that the vector dimension is 768, this will be checked during mutations (insert/update) and in similarity search queries."]}),"\n",(0,l.jsx)(n.h3,{id:"calculated-fields-2",children:"Calculated fields"}),"\n",(0,l.jsxs)(n.p,{children:["For each ",(0,l.jsx)(n.code,{children:"Vector"})," table or view field, a new field will be generated with the name: ",(0,l.jsx)(n.code,{children:"_<field_name>_distance"}),", type ",(0,l.jsx)(n.code,{children:"Float"}),", and the following parameters:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"vector: Vector"})," - The vector to calculate the distance to."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"distance: VectorDistanceType"})," - The type of distance to calculate."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["If the data object has the ",(0,l.jsx)(n.code,{children:"@embeddings"})," directive defined, the field ",(0,l.jsx)(n.code,{children:"_distance_query_to"})," will be generated, which calculates the distance from the vector field to the query text. The field returns ",(0,l.jsx)(n.code,{children:"Float"})," and has the one parameter: ",(0,l.jsx)(n.code,{children:"query: String!"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-6",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the vector is null."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"aggregation-functions-6",children:"Aggregation functions"}),"\n",(0,l.jsxs)(n.p,{children:["The aggregations are not supported for the ",(0,l.jsx)(n.code,{children:"Vector"})," type."]}),"\n",(0,l.jsx)(n.h3,{id:"vector-similarity-search",children:"Vector similarity search"}),"\n",(0,l.jsxs)(n.p,{children:["For ",(0,l.jsx)(n.code,{children:"Vector"})," fields, the ",(0,l.jsx)(n.code,{children:"similarity"})," argument will be generated in the queries. This argument accepts input values in the following format:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'input VectorSearchInput @system {\n  "The name of vector field"\n  name: String!\n  "The vector to search"\n  vector: Vector!\n  "Distance type"\n  distance: VectorDistanceType!\n  "Limit to results"\n  limit: Int!\n}\n\nenum VectorDistanceType @system {\n  "L2 distance"\n  L2\n  "Cosine similarity"\n  Cosine\n  "Inner product"\n  Inner\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["This argument allows you to perform similarity searches on vector fields. For example, to find the 10 most similar vectors to a given vector using cosine similarity in table ",(0,l.jsx)(n.code,{children:"items"})," with vector field ",(0,l.jsx)(n.code,{children:"embedding"}),", you would write:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  items(\n    similarity: {\n      name: "embedding"\n      vector: [0.1, 0.2, 0.3]\n      distance: Cosine\n      limit: 10\n    }\n  ) {\n    id\n    name\n    embedding\n  }\n}    \n'})}),"\n",(0,l.jsxs)(n.p,{children:["You can also combine similarity searches and filters. For example, to find the 5 most similar vectors to a given vector using L2 distance in table ",(0,l.jsx)(n.code,{children:"items"})," with vector field ",(0,l.jsx)(n.code,{children:"embedding"}),", where the ",(0,l.jsx)(n.code,{children:"category"}),' is "books", you would write:']}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  items(\n    similarity: {\n      name: "embedding"\n      vector: [0.1, 0.2, 0.3]\n      distance: L2\n      limit: 5\n    }\n    filter: {\n      category: { eq: "books" }\n    }\n  ) {\n    id\n    name\n    embedding\n  }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"list-types",children:"List types"}),"\n",(0,l.jsxs)(n.p,{children:["Data types can be GraphQL list types, which are denoted by square brackets ",(0,l.jsx)(n.code,{children:"[]"}),". For example: ",(0,l.jsx)(n.code,{children:"[String!]"}),", ",(0,l.jsx)(n.code,{children:"[Int!]"}),", ",(0,l.jsx)(n.code,{children:"[Float!]"}),", etc. List types can be used to represent arrays of values."]}),"\n",(0,l.jsxs)(n.p,{children:["List types cannot be aggregated, but can be filtered.\nOnly the following list data types can be filtered: ",(0,l.jsx)(n.code,{children:"[String]"}),", ",(0,l.jsx)(n.code,{children:"[Int]"}),", ",(0,l.jsx)(n.code,{children:"[Float]"}),", ",(0,l.jsx)(n.code,{children:"[Boolean]"}),", ",(0,l.jsx)(n.code,{children:"[Date]"}),", ",(0,l.jsx)(n.code,{children:"[Timestamp]"}),", ",(0,l.jsx)(n.code,{children:"[Interval]"})]}),"\n",(0,l.jsx)(n.h3,{id:"filter-operations-7",children:"Filter operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"eq"})," - Checks if the list contains a specific value."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"contains"})," - Checks if the list contains another list."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"intersects"})," - Checks if the list intersects with another list."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_null"})," - Checks if the list is null."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const l={},t=s.createContext(l);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);